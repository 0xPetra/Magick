/*! For license information please see vendor-node_modules_psychedelic_dab-js_dist_index_js-node_modules_ot-json0_lib_index_js-node_-12eba2.c9310cbf29b95db45b93-1.bundle.js.LICENSE.txt */
(self.webpackChunk_thothai_thoth_client=self.webpackChunk_thothai_thoth_client||[]).push([["vendor-node_modules_psychedelic_dab-js_dist_index_js-node_modules_ot-json0_lib_index_js-node_-12eba2"],{"../../node_modules/@psychedelic/dab-js/dist/constants/canisters.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NFT_CANISTERS = void 0;\nexports.NFT_CANISTERS = {\n    WRAPPED_PUNKS: 'bxdf4-baaaa-aaaah-qaruq-cai',\n    WRAPPED_DRIP: '3db6u-aiaaa-aaaah-qbjbq-cai',\n    IC_PUNKS: 'qcg3w-tyaaa-aaaah-qakea-cai',\n    IC_DRIP: 'd3ttm-qaaaa-aaaai-qam4a-cai',\n    ICP_BUNNY_MAIN: 'xkbqi-2qaaa-aaaah-qbpqq-cai',\n    ICP_BUNNY_STORAGE: [\n        'efqhu-yqaaa-aaaaf-qaeda-cai',\n        'ecrba-viaaa-aaaaf-qaedq-cai',\n        'fp7fo-2aaaa-aaaaf-qaeea-cai',\n        'fi6d2-xyaaa-aaaaf-qaeeq-cai',\n        'fb5ig-bqaaa-aaaaf-qaefa-cai',\n        'fg4os-miaaa-aaaaf-qaefq-cai',\n        'ft377-naaaa-aaaaf-qaega-cai',\n        'fu2zl-ayaaa-aaaaf-qaegq-cai',\n        'f5zsx-wqaaa-aaaaf-qaeha-cai',\n        'f2yud-3iaaa-aaaaf-qaehq-cai',\n    ],\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/constants/canisters.js?")},"../../node_modules/@psychedelic/dab-js/dist/constants/index.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KYASSHU_URL = exports.IC_HOST = void 0;\nexports.IC_HOST = 'https://ic0.app/';\nexports.KYASSHU_URL = 'https://kyasshu.fleek.co';\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/constants/index.js?")},"../../node_modules/@psychedelic/dab-js/dist/constants/standards.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NFT = exports.TOKEN = void 0;\nexports.TOKEN = {\n    dip20: 'DIP20',\n    xtc: 'XTC',\n    wicp: 'WICP',\n    ext: 'EXT',\n    icp: 'ICP'\n};\nexports.NFT = {\n    ext: 'EXT',\n    icpunks: 'ICPunks',\n    departuresLabs: 'DepartureLabs',\n    erc721: 'ERC721',\n    dip721: 'DIP721',\n    dip721v2: 'DIP721v2',\n    c3: 'C3'\n};\nexports[\"default\"] = {\n    TOKEN: exports.TOKEN, NFT: exports.NFT\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/constants/standards.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/c3.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const TokenIndex__1 = IDL.Nat;\n    const TokenIndex = IDL.Nat;\n    const TransferResponse = IDL.Variant({\n        'ok': TokenIndex,\n        'err': IDL.Variant({\n            'ListOnMarketPlace': IDL.Null,\n            'NotAllowTransferToSelf': IDL.Null,\n            'NotOwnerOrNotApprove': IDL.Null,\n            'Other': IDL.Null,\n        }),\n    });\n    const TokenDetails = IDL.Record({\n        'id': IDL.Nat,\n        'rarityScore': IDL.Float64,\n    });\n    const GetTokenResponse = IDL.Variant({\n        'ok': TokenDetails,\n        'err': IDL.Variant({ 'NotFoundIndex': IDL.Null }),\n    });\n    const C2NFT = IDL.Service({\n        'getAllNFT': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(TokenIndex__1, IDL.Principal))], ['query']),\n        'getNftStoreCIDByIndex': IDL.Func([TokenIndex__1], [IDL.Principal], ['query']),\n        'getTokenById': IDL.Func([IDL.Nat], [GetTokenResponse], ['query']),\n        'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, TokenIndex__1], [TransferResponse], []),\n    });\n    return C2NFT;\n};\nconst init = ({ IDL }) => {\n    return [IDL.Principal, IDL.Principal, IDL.Principal];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/c3.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst addressBookIDL = ({ IDL }) => {\n    const valueType = IDL.Variant({\n        'PrincipalId': IDL.Principal,\n        'AccountId': IDL.Text,\n        'Icns': IDL.Text,\n    });\n    const address = IDL.Record({\n        'name': IDL.Text,\n        'description': IDL.Opt(IDL.Text),\n        'emoji': IDL.Opt(IDL.Text),\n        'value': valueType,\n    });\n    const operation_error = IDL.Variant({\n        'NotAuthorized': IDL.Null,\n        'BadParameters': IDL.Null,\n        'Unknown': IDL.Text,\n        'NonExistentItem': IDL.Null,\n    });\n    const operation_response = IDL.Variant({\n        'Ok': IDL.Null,\n        'Err': operation_error,\n    });\n    return IDL.Service({\n        'add': IDL.Func([address], [operation_response], []),\n        'get_all': IDL.Func([], [IDL.Vec(address)], []),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'remove': IDL.Func([IDL.Text], [operation_response], []),\n    });\n};\nexports[\"default\"] = addressBookIDL;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const detail_value = IDL.Rec();\n    detail_value.fill(IDL.Variant({\n        'I64': IDL.Int64,\n        'U64': IDL.Nat64,\n        'Vec': IDL.Vec(detail_value),\n        'Slice': IDL.Vec(IDL.Nat8),\n        'Text': IDL.Text,\n        'True': IDL.Null,\n        'False': IDL.Null,\n        'Float': IDL.Float64,\n        'Principal': IDL.Principal,\n    }));\n    const canister_metadata = IDL.Record({\n        'thumbnail': IDL.Text,\n        'name': IDL.Text,\n        'frontend': IDL.Opt(IDL.Text),\n        'description': IDL.Text,\n        'principal_id': IDL.Principal,\n        'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),\n    });\n    const operation_error = IDL.Variant({\n        'NotAuthorized': IDL.Null,\n        'BadParameters': IDL.Null,\n        'Unknown': IDL.Text,\n        'NonExistentItem': IDL.Null,\n    });\n    const operation_response = IDL.Variant({\n        'Ok': IDL.Opt(IDL.Text),\n        'Err': operation_error,\n    });\n    return IDL.Service({\n        'add': IDL.Func([canister_metadata], [operation_response], []),\n        'get': IDL.Func([IDL.Principal], [IDL.Opt(canister_metadata)], ['query']),\n        'get_all': IDL.Func([], [IDL.Vec(canister_metadata)], ['query']),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'remove': IDL.Func([IDL.Principal], [operation_response], []),\n    });\n};\nconst init = () => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const detail_value = IDL.Rec();\n    detail_value.fill(IDL.Variant({\n        'I64': IDL.Int64,\n        'U64': IDL.Nat64,\n        'Vec': IDL.Vec(detail_value),\n        'Slice': IDL.Vec(IDL.Nat8),\n        'Text': IDL.Text,\n        'True': IDL.Null,\n        'False': IDL.Null,\n        'Float': IDL.Float64,\n        'Principal': IDL.Principal,\n    }));\n    const nft_canister = IDL.Record({\n        'thumbnail': IDL.Text,\n        'name': IDL.Text,\n        'frontend': IDL.Opt(IDL.Text),\n        'description': IDL.Text,\n        'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),\n        'principal_id': IDL.Principal,\n    });\n    const operation_error = IDL.Variant({\n        'NotAuthorized': IDL.Null,\n        'BadParameters': IDL.Null,\n        'Unknown': IDL.Text,\n        'NonExistentItem': IDL.Null,\n    });\n    const operation_response = IDL.Variant({\n        'Ok': IDL.Opt(IDL.Text),\n        'Err': operation_error,\n    });\n    return IDL.Service({\n        'add': IDL.Func([nft_canister], [operation_response], []),\n        'get': IDL.Func([IDL.Principal], [IDL.Opt(nft_canister)], ['query']),\n        'get_all': IDL.Func([], [IDL.Vec(nft_canister)], ['query']),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'remove': IDL.Func([IDL.Principal], [operation_response], []),\n        'set_controller': IDL.Func([IDL.Principal], [operation_response], []),\n    });\n};\nconst init = () => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const detail_value = IDL.Rec();\n    detail_value.fill(IDL.Variant({\n        'I64': IDL.Int64,\n        'U64': IDL.Nat64,\n        'Vec': IDL.Vec(detail_value),\n        'Slice': IDL.Vec(IDL.Nat8),\n        'Text': IDL.Text,\n        'True': IDL.Null,\n        'False': IDL.Null,\n        'Float': IDL.Float64,\n        'Principal': IDL.Principal,\n    }));\n    const metadata = IDL.Record({\n        'thumbnail': IDL.Text,\n        'name': IDL.Text,\n        'frontend': IDL.Opt(IDL.Text),\n        'description': IDL.Text,\n        'principal_id': IDL.Principal,\n        'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),\n    });\n    const error = IDL.Variant({\n        'NotAuthorized': IDL.Null,\n        'BadParameters': IDL.Null,\n        'Unknown': IDL.Text,\n        'NonExistantCanister': IDL.Null,\n    });\n    const response = IDL.Variant({ 'Ok': IDL.Opt(IDL.Text), 'Err': error });\n    return IDL.Service({\n        'add': IDL.Func([metadata], [response], []),\n        'get': IDL.Func([IDL.Principal], [IDL.Opt(metadata)], ['query']),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'remove': IDL.Func([IDL.Principal], [response], []),\n    });\n};\nconst init = () => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const detail_value = IDL.Rec();\n    detail_value.fill(IDL.Variant({\n        'I64': IDL.Int64,\n        'U64': IDL.Nat64,\n        'Vec': IDL.Vec(detail_value),\n        'Slice': IDL.Vec(IDL.Nat8),\n        'Text': IDL.Text,\n        'True': IDL.Null,\n        'False': IDL.Null,\n        'Float': IDL.Float64,\n        'Principal': IDL.Principal,\n    }));\n    const token = IDL.Record({\n        'thumbnail': IDL.Text,\n        'name': IDL.Text,\n        'frontend': IDL.Opt(IDL.Text),\n        'description': IDL.Text,\n        'principal_id': IDL.Principal,\n        'details': IDL.Vec(IDL.Tuple(IDL.Text, detail_value)),\n    });\n    const operation_error = IDL.Variant({\n        'NotAuthorized': IDL.Null,\n        'BadParameters': IDL.Null,\n        'Unknown': IDL.Text,\n        'NonExistentItem': IDL.Null,\n    });\n    const operation_response = IDL.Variant({\n        'Ok': IDL.Opt(IDL.Text),\n        'Err': operation_error,\n    });\n    return IDL.Service({\n        'add': IDL.Func([token], [operation_response], []),\n        'get': IDL.Func([IDL.Principal], [IDL.Opt(token)], ['query']),\n        'get_all': IDL.Func([], [IDL.Vec(token)], ['query']),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'remove': IDL.Func([IDL.Principal], [operation_response], []),\n        'set_controller': IDL.Func([IDL.Principal], [operation_response], []),\n    });\n};\nconst init = () => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const Property = IDL.Rec();\n    const Query = IDL.Rec();\n    const Update = IDL.Rec();\n    const Callback = IDL.Func([], [], []);\n    const StagedWrite = IDL.Variant({\n        'Init': IDL.Record({ 'size': IDL.Nat, 'callback': IDL.Opt(Callback) }),\n        'Chunk': IDL.Record({\n            'chunk': IDL.Vec(IDL.Nat8),\n            'callback': IDL.Opt(Callback),\n        }),\n    });\n    const AssetRequest = IDL.Variant({\n        'Put': IDL.Record({\n            'key': IDL.Text,\n            'contentType': IDL.Text,\n            'callback': IDL.Opt(Callback),\n            'payload': IDL.Variant({\n                'StagedData': IDL.Null,\n                'Payload': IDL.Vec(IDL.Nat8),\n            }),\n        }),\n        'Remove': IDL.Record({ 'key': IDL.Text, 'callback': IDL.Opt(Callback) }),\n        'StagedWrite': StagedWrite,\n    });\n    const AuthorizeRequest = IDL.Record({\n        'p': IDL.Principal,\n        'id': IDL.Text,\n        'isAuthorized': IDL.Bool,\n    });\n    const Error = IDL.Variant({\n        'Immutable': IDL.Null,\n        'NotFound': IDL.Null,\n        'Unauthorized': IDL.Null,\n        'InvalidRequest': IDL.Null,\n        'AuthorizedPrincipalLimitReached': IDL.Nat,\n    });\n    const Result_1 = IDL.Variant({ 'ok': IDL.Null, 'err': Error });\n    const ContractInfo = IDL.Record({\n        'nft_payload_size': IDL.Nat,\n        'memory_size': IDL.Nat,\n        'max_live_size': IDL.Nat,\n        'cycles': IDL.Nat,\n        'total_minted': IDL.Nat,\n        'heap_size': IDL.Nat,\n        'authorized_users': IDL.Vec(IDL.Principal),\n    });\n    const TopupCallback = IDL.Func([], [], []);\n    const Contract = IDL.Variant({\n        'ContractAuthorize': IDL.Record({\n            'isAuthorized': IDL.Bool,\n            'user': IDL.Principal,\n        }),\n        'Mint': IDL.Record({ 'id': IDL.Text, 'owner': IDL.Principal }),\n    });\n    const Token = IDL.Variant({\n        'Authorize': IDL.Record({\n            'id': IDL.Text,\n            'isAuthorized': IDL.Bool,\n            'user': IDL.Principal,\n        }),\n        'Transfer': IDL.Record({\n            'id': IDL.Text,\n            'to': IDL.Principal,\n            'from': IDL.Principal,\n        }),\n    });\n    const Message = IDL.Record({\n        'topupCallback': TopupCallback,\n        'createdAt': IDL.Int,\n        'topupAmount': IDL.Nat,\n        'event': IDL.Variant({ 'ContractEvent': Contract, 'TokenEvent': Token }),\n    });\n    const Callback__1 = IDL.Func([Message], [], []);\n    const CallbackStatus = IDL.Record({\n        'failedCalls': IDL.Nat,\n        'failedCallsLimit': IDL.Nat,\n        'callback': IDL.Opt(Callback__1),\n        'noTopupCallLimit': IDL.Nat,\n        'callsSinceLastTopup': IDL.Nat,\n    });\n    const ContractMetadata = IDL.Record({\n        'name': IDL.Text,\n        'symbol': IDL.Text,\n    });\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\n    const Request = IDL.Record({\n        'url': IDL.Text,\n        'method': IDL.Text,\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n    });\n    const StreamingCallbackToken = IDL.Record({\n        'key': IDL.Text,\n        'index': IDL.Nat,\n        'content_encoding': IDL.Text,\n    });\n    const StreamingCallbackResponse = IDL.Record({\n        'token': IDL.Opt(StreamingCallbackToken),\n        'body': IDL.Vec(IDL.Nat8),\n    });\n    const StreamingCallback = IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']);\n    const StreamingStrategy = IDL.Variant({\n        'Callback': IDL.Record({\n            'token': StreamingCallbackToken,\n            'callback': StreamingCallback,\n        }),\n    });\n    const Response = IDL.Record({\n        'body': IDL.Vec(IDL.Nat8),\n        'headers': IDL.Vec(HeaderField),\n        'streaming_strategy': IDL.Opt(StreamingStrategy),\n        'status_code': IDL.Nat16,\n    });\n    const Value = IDL.Variant({\n        'Int': IDL.Int,\n        'Nat': IDL.Nat,\n        'Empty': IDL.Null,\n        'Bool': IDL.Bool,\n        'Text': IDL.Text,\n        'Float': IDL.Float64,\n        'Principal': IDL.Principal,\n        'Class': IDL.Vec(Property),\n    });\n    Property.fill(IDL.Record({ 'value': Value, 'name': IDL.Text, 'immutable': IDL.Bool }));\n    const Properties = IDL.Vec(Property);\n    const Egg = IDL.Record({\n        'contentType': IDL.Text,\n        'owner': IDL.Opt(IDL.Principal),\n        'properties': Properties,\n        'isPrivate': IDL.Bool,\n        'payload': IDL.Variant({\n            'StagedData': IDL.Null,\n            'Payload': IDL.Vec(IDL.Nat8),\n        }),\n    });\n    const Result_5 = IDL.Variant({ 'ok': IDL.Principal, 'err': Error });\n    Query.fill(IDL.Record({ 'name': IDL.Text, 'next': IDL.Vec(Query) }));\n    const QueryMode = IDL.Variant({ 'All': IDL.Null, 'Some': IDL.Vec(Query) });\n    const QueryRequest = IDL.Record({ 'id': IDL.Text, 'mode': QueryMode });\n    const Result = IDL.Variant({ 'ok': Properties, 'err': Error });\n    const Chunk = IDL.Record({\n        'data': IDL.Vec(IDL.Nat8),\n        'totalPages': IDL.Nat,\n        'nextPage': IDL.Opt(IDL.Nat),\n    });\n    const PayloadResult = IDL.Variant({\n        'Complete': IDL.Vec(IDL.Nat8),\n        'Chunk': Chunk,\n    });\n    const PublicToken = IDL.Record({\n        'id': IDL.Text,\n        'contentType': IDL.Text,\n        'owner': IDL.Principal,\n        'createdAt': IDL.Int,\n        'properties': Properties,\n        'payload': PayloadResult,\n    });\n    const Result_4 = IDL.Variant({ 'ok': PublicToken, 'err': Error });\n    const Result_3 = IDL.Variant({ 'ok': Chunk, 'err': Error });\n    const Metadata = IDL.Record({\n        'id': IDL.Text,\n        'contentType': IDL.Text,\n        'owner': IDL.Principal,\n        'createdAt': IDL.Int,\n        'properties': Properties,\n    });\n    const Result_2 = IDL.Variant({ 'ok': Metadata, 'err': Error });\n    const UpdateEventCallback = IDL.Variant({\n        'Set': Callback__1,\n        'Remove': IDL.Null,\n    });\n    const UpdateMode = IDL.Variant({ 'Set': Value, 'Next': IDL.Vec(Update) });\n    Update.fill(IDL.Record({ 'mode': UpdateMode, 'name': IDL.Text }));\n    const UpdateRequest = IDL.Record({\n        'id': IDL.Text,\n        'update': IDL.Vec(Update),\n    });\n    const Hub = IDL.Service({\n        'assetRequest': IDL.Func([AssetRequest], [], []),\n        'authorize': IDL.Func([AuthorizeRequest], [Result_1], []),\n        'balanceOf': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Text)], []),\n        'getAuthorized': IDL.Func([IDL.Text], [IDL.Vec(IDL.Principal)], ['query']),\n        'getContractInfo': IDL.Func([], [ContractInfo], []),\n        'getEventCallbackStatus': IDL.Func([], [CallbackStatus], []),\n        'getMetadata': IDL.Func([], [ContractMetadata], ['query']),\n        'getTotalMinted': IDL.Func([], [IDL.Nat], ['query']),\n        'http_request': IDL.Func([Request], [Response], ['query']),\n        'http_request_streaming_callback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),\n        'init': IDL.Func([IDL.Vec(IDL.Principal), ContractMetadata], [], []),\n        'isAuthorized': IDL.Func([IDL.Text, IDL.Principal], [IDL.Bool], ['query']),\n        'listAssets': IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text, IDL.Nat))], ['query']),\n        'mint': IDL.Func([Egg], [IDL.Text], []),\n        'nftStreamingCallback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),\n        'ownerOf': IDL.Func([IDL.Text], [Result_5], ['query']),\n        'queryProperties': IDL.Func([QueryRequest], [Result], ['query']),\n        'staticStreamingCallback': IDL.Func([StreamingCallbackToken], [StreamingCallbackResponse], ['query']),\n        'tokenByIndex': IDL.Func([IDL.Text], [Result_4], []),\n        'tokenChunkByIndex': IDL.Func([IDL.Text, IDL.Nat], [Result_3], []),\n        'tokenMetadataByIndex': IDL.Func([IDL.Text], [Result_2], []),\n        'transfer': IDL.Func([IDL.Principal, IDL.Text], [Result_1], []),\n        'updateContractOwners': IDL.Func([IDL.Principal, IDL.Bool], [Result_1], []),\n        'updateEventCallback': IDL.Func([UpdateEventCallback], [], []),\n        'updateProperties': IDL.Func([UpdateRequest], [Result], []),\n        'wallet_receive': IDL.Func([], [], []),\n        'writeStaged': IDL.Func([StagedWrite], [], []),\n    });\n    return Hub;\n};\nconst init = ({}) => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const TxError = IDL.Variant({\n        'InsufficientAllowance': IDL.Null,\n        'InsufficientBalance': IDL.Null,\n        'ErrorOperationStyle': IDL.Null,\n        'Unauthorized': IDL.Null,\n        'LedgerTrap': IDL.Null,\n        'ErrorTo': IDL.Null,\n        'Other': IDL.Null,\n        'BlockUsed': IDL.Null,\n        'AmountTooSmall': IDL.Null,\n    });\n    const Result = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });\n    const Metadata = IDL.Record({\n        'fee': IDL.Nat,\n        'decimals': IDL.Nat8,\n        'owner': IDL.Principal,\n        'logo': IDL.Text,\n        'name': IDL.Text,\n        'totalSupply': IDL.Nat,\n        'symbol': IDL.Text,\n    });\n    const TokenInfo = IDL.Record({\n        'holderNumber': IDL.Nat64,\n        'deployTime': IDL.Nat64,\n        'metadata': Metadata,\n        'historySize': IDL.Nat64,\n        'cycles': IDL.Nat64,\n        'feeTo': IDL.Principal,\n    });\n    return IDL.Service({\n        'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),\n        'approve': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),\n        'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),\n        'decimals': IDL.Func([], [IDL.Nat8], ['query']),\n        'getAllowanceSize': IDL.Func([], [IDL.Nat64], ['query']),\n        'getBlockUsed': IDL.Func([], [IDL.Vec(IDL.Nat64)], ['query']),\n        'getHolders': IDL.Func([IDL.Nat64, IDL.Nat64], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),\n        'getMetadata': IDL.Func([], [Metadata], ['query']),\n        'getTokenInfo': IDL.Func([], [TokenInfo], ['query']),\n        'getUserApprovals': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),\n        'historySize': IDL.Func([], [IDL.Nat64], ['query']),\n        'isBlockUsed': IDL.Func([IDL.Nat64], [IDL.Bool], ['query']),\n        'logo': IDL.Func([], [IDL.Text], ['query']),\n        'mint': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64], [Result], []),\n        'mintFor': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64, IDL.Principal], [Result], []),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'owner': IDL.Func([], [IDL.Principal], ['query']),\n        'setFee': IDL.Func([IDL.Nat], [], []),\n        'setFeeTo': IDL.Func([IDL.Principal], [], []),\n        'setGenesis': IDL.Func([], [Result], []),\n        'setLogo': IDL.Func([IDL.Text], [], []),\n        'setName': IDL.Func([IDL.Text], [], []),\n        'setOwner': IDL.Func([IDL.Principal], [], []),\n        'symbol': IDL.Func([], [IDL.Text], ['query']),\n        'totalSupply': IDL.Func([], [IDL.Nat], ['query']),\n        'transfer': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),\n        'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result], []),\n        'withdraw': IDL.Func([IDL.Nat64, IDL.Text], [Result], []),\n    });\n};\nconst init = ({ IDL }) => {\n    return [\n        IDL.Text,\n        IDL.Text,\n        IDL.Text,\n        IDL.Nat8,\n        IDL.Nat,\n        IDL.Principal,\n        IDL.Nat,\n        IDL.Principal,\n        IDL.Principal,\n    ];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const AccountIdentifier = IDL.Text;\n    const User = IDL.Variant({\n        'principal': IDL.Principal,\n        'address': AccountIdentifier,\n    });\n    const TokenIdentifier = IDL.Text;\n    const Memo = IDL.Vec(IDL.Nat8);\n    const SubAccount = IDL.Vec(IDL.Nat8);\n    const Balance = IDL.Nat;\n    const TransferRequest = IDL.Record({\n        'to': User,\n        'token': TokenIdentifier,\n        'notify': IDL.Bool,\n        'from': User,\n        'memo': Memo,\n        'subaccount': IDL.Opt(SubAccount),\n        'amount': Balance,\n    });\n    const TransactionId = IDL.Nat;\n    const CommonError = IDL.Variant({\n        'InvalidToken': TokenIdentifier,\n        'Other': IDL.Text,\n    });\n    const AccountIdentifierReturn = IDL.Variant({\n        'Ok': AccountIdentifier,\n        'Err': CommonError,\n    });\n    const Value = IDL.Variant({\n        'nat': IDL.Nat,\n        'blob': IDL.Vec(IDL.Nat8),\n        'nat8': IDL.Nat8,\n        'text': IDL.Text,\n    });\n    const MetadataValue = IDL.Tuple(IDL.Text, Value);\n    const MetadataContainer = IDL.Variant({\n        'blob': IDL.Vec(IDL.Nat8),\n        'data': IDL.Vec(MetadataValue),\n        'json': IDL.Text,\n    });\n    const Metadata = IDL.Variant({\n        'fungible': IDL.Record({\n            'decimals': IDL.Nat8,\n            'metadata': IDL.Opt(MetadataContainer),\n            'name': IDL.Text,\n            'symbol': IDL.Text,\n        }),\n        'nonfungible': IDL.Opt(MetadataContainer),\n    });\n    const TokenMetadata = IDL.Record({\n        'principal': IDL.Principal,\n        'metadata': Metadata,\n        'account_identifier': AccountIdentifier,\n        'token_identifier': TokenIdentifier,\n    });\n    const MetadataVal = IDL.Variant({\n        'Nat64Content': IDL.Nat64,\n        'Nat32Content': IDL.Nat32,\n        'Nat8Content': IDL.Nat8,\n        'NatContent': IDL.Nat,\n        'Nat16Content': IDL.Nat16,\n        'BlobContent': IDL.Vec(IDL.Nat8),\n        'TextContent': IDL.Text,\n    });\n    const MetadataKeyVal = IDL.Record({ 'key': IDL.Text, 'val': MetadataVal });\n    const MetadataPurpose = IDL.Variant({\n        'Preview': IDL.Null,\n        'Rendered': IDL.Null,\n    });\n    const MetadataPart = IDL.Record({\n        'data': IDL.Vec(IDL.Nat8),\n        'key_val_data': IDL.Vec(MetadataKeyVal),\n        'purpose': MetadataPurpose,\n    });\n    const MetadataDesc = IDL.Vec(MetadataPart);\n    const ApiError = IDL.Variant({\n        'ZeroAddress': IDL.Null,\n        'InvalidTokenId': IDL.Null,\n        'Unauthorized': IDL.Null,\n        'Other': IDL.Null,\n    });\n    const MetadataResult = IDL.Variant({ 'Ok': MetadataDesc, 'Err': ApiError });\n    const ExtendedMetadataResult = IDL.Record({\n        'token_id': IDL.Nat64,\n        'metadata_desc': MetadataDesc,\n    });\n    const LogoResult = IDL.Record({ 'data': IDL.Text, 'logo_type': IDL.Text });\n    const MetadataReturn = IDL.Variant({ 'Ok': Metadata, 'Err': CommonError });\n    const MintReceiptPart = IDL.Record({\n        'id': IDL.Nat,\n        'token_id': IDL.Nat64,\n    });\n    const MintReceipt = IDL.Variant({ 'Ok': MintReceiptPart, 'Err': ApiError });\n    const MintRequest = IDL.Record({\n        'to': User,\n        'metadata': IDL.Opt(MetadataContainer),\n    });\n    const OwnerResult = IDL.Variant({ 'Ok': IDL.Principal, 'Err': ApiError });\n    const TxReceipt = IDL.Variant({ 'Ok': IDL.Nat, 'Err': ApiError });\n    const BalanceReturn = IDL.Variant({ 'Ok': Balance, 'Err': CommonError });\n    const InterfaceId = IDL.Variant({\n        'Burn': IDL.Null,\n        'Mint': IDL.Null,\n        'Approval': IDL.Null,\n        'TransactionHistory': IDL.Null,\n        'TransferNotification': IDL.Null,\n    });\n    const TransferResponse = IDL.Variant({\n        'Ok': Balance,\n        'Err': IDL.Variant({\n            'CannotNotify': AccountIdentifier,\n            'InsufficientBalance': IDL.Null,\n            'InvalidToken': TokenIdentifier,\n            'Rejected': IDL.Null,\n            'Unauthorized': AccountIdentifier,\n            'Other': IDL.Text,\n        }),\n    });\n    const erc721_token = IDL.Service({\n        'add': IDL.Func([TransferRequest], [TransactionId], []),\n        'balanceOfDip721': IDL.Func([IDL.Principal], [IDL.Nat64], ['query']),\n        'bearer': IDL.Func([TokenIdentifier], [AccountIdentifierReturn], ['query']),\n        'getAllMetadataForUser': IDL.Func([User], [IDL.Vec(TokenMetadata)], ['query']),\n        'getMaxLimitDip721': IDL.Func([], [IDL.Nat16], ['query']),\n        'getMetadataDip721': IDL.Func([IDL.Nat64], [MetadataResult], ['query']),\n        'getMetadataForUserDip721': IDL.Func([IDL.Principal], [IDL.Vec(ExtendedMetadataResult)], []),\n        'logoDip721': IDL.Func([], [LogoResult], ['query']),\n        'metadata': IDL.Func([TokenIdentifier], [MetadataReturn], ['query']),\n        'mintDip721': IDL.Func([IDL.Principal, MetadataDesc], [MintReceipt], []),\n        'mintNFT': IDL.Func([MintRequest], [TokenIdentifier], []),\n        'nameDip721': IDL.Func([], [IDL.Text], ['query']),\n        'ownerOfDip721': IDL.Func([IDL.Nat64], [OwnerResult], ['query']),\n        'safeTransferFromDip721': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat64], [TxReceipt], []),\n        'supply': IDL.Func([TokenIdentifier], [BalanceReturn], ['query']),\n        'supportedInterfacesDip721': IDL.Func([], [IDL.Vec(InterfaceId)], ['query']),\n        'symbolDip721': IDL.Func([], [IDL.Text], ['query']),\n        'totalSupplyDip721': IDL.Func([], [IDL.Nat64], ['query']),\n        'transfer': IDL.Func([TransferRequest], [TransferResponse], []),\n        'transferFromDip721': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat64], [TxReceipt], []),\n    });\n    return erc721_token;\n};\nconst init = ({ IDL }) => {\n    return [IDL.Principal, IDL.Text, IDL.Text, IDL.Principal];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/dip_721_v2.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const Vec = IDL.Rec();\n    const InitArgs = IDL.Record({\n        'logo': IDL.Opt(IDL.Text),\n        'name': IDL.Opt(IDL.Text),\n        'custodians': IDL.Opt(IDL.Vec(IDL.Principal)),\n        'symbol': IDL.Opt(IDL.Text),\n    });\n    const NftError = IDL.Variant({\n        'UnauthorizedOperator': IDL.Null,\n        'SelfTransfer': IDL.Null,\n        'TokenNotFound': IDL.Null,\n        'UnauthorizedOwner': IDL.Null,\n        'TxNotFound': IDL.Null,\n        'SelfApprove': IDL.Null,\n        'OperatorNotFound': IDL.Null,\n        'ExistedNFT': IDL.Null,\n        'OwnerNotFound': IDL.Null,\n        'Other': IDL.Text,\n    });\n    const Result = IDL.Variant({ 'Ok': IDL.Nat, 'Err': NftError });\n    const Result_1 = IDL.Variant({ 'Ok': IDL.Bool, 'Err': NftError });\n    const ManualReply = IDL.Record({\n        'logo': IDL.Opt(IDL.Text),\n        'name': IDL.Opt(IDL.Text),\n        'created_at': IDL.Nat64,\n        'upgraded_at': IDL.Nat64,\n        'custodians': IDL.Vec(IDL.Principal),\n        'symbol': IDL.Opt(IDL.Text),\n    });\n    Vec.fill(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Variant({\n        'Nat64Content': IDL.Nat64,\n        'Nat32Content': IDL.Nat32,\n        'BoolContent': IDL.Bool,\n        'Nat8Content': IDL.Nat8,\n        'Int64Content': IDL.Int64,\n        'IntContent': IDL.Int,\n        'NatContent': IDL.Nat,\n        'Nat16Content': IDL.Nat16,\n        'Int32Content': IDL.Int32,\n        'Int8Content': IDL.Int8,\n        'FloatContent': IDL.Float64,\n        'Int16Content': IDL.Int16,\n        'BlobContent': IDL.Vec(IDL.Nat8),\n        'NestedContent': Vec,\n        'Principal': IDL.Principal,\n        'TextContent': IDL.Text,\n    }))));\n    const GenericValue = IDL.Variant({\n        'Nat64Content': IDL.Nat64,\n        'Nat32Content': IDL.Nat32,\n        'BoolContent': IDL.Bool,\n        'Nat8Content': IDL.Nat8,\n        'Int64Content': IDL.Int64,\n        'IntContent': IDL.Int,\n        'NatContent': IDL.Nat,\n        'Nat16Content': IDL.Nat16,\n        'Int32Content': IDL.Int32,\n        'Int8Content': IDL.Int8,\n        'FloatContent': IDL.Float64,\n        'Int16Content': IDL.Int16,\n        'BlobContent': IDL.Vec(IDL.Nat8),\n        'NestedContent': Vec,\n        'Principal': IDL.Principal,\n        'TextContent': IDL.Text,\n    });\n    const Result_2 = IDL.Variant({\n        'Ok': IDL.Opt(IDL.Principal),\n        'Err': NftError,\n    });\n    const ManualReply_1 = IDL.Variant({\n        'Ok': IDL.Vec(IDL.Nat),\n        'Err': NftError,\n    });\n    const TokenMetadata = IDL.Record({\n        'transferred_at': IDL.Opt(IDL.Nat64),\n        'transferred_by': IDL.Opt(IDL.Principal),\n        'owner': IDL.Opt(IDL.Principal),\n        'operator': IDL.Opt(IDL.Principal),\n        'approved_at': IDL.Opt(IDL.Nat64),\n        'approved_by': IDL.Opt(IDL.Principal),\n        'properties': IDL.Vec(IDL.Tuple(IDL.Text, GenericValue)),\n        'is_burned': IDL.Bool,\n        'token_identifier': IDL.Nat,\n        'burned_at': IDL.Opt(IDL.Nat64),\n        'burned_by': IDL.Opt(IDL.Principal),\n        'minted_at': IDL.Nat64,\n        'minted_by': IDL.Principal,\n    });\n    const ManualReply_2 = IDL.Variant({\n        'Ok': IDL.Vec(TokenMetadata),\n        'Err': NftError,\n    });\n    const Stats = IDL.Record({\n        'cycles': IDL.Nat,\n        'total_transactions': IDL.Nat,\n        'total_unique_holders': IDL.Nat,\n        'total_supply': IDL.Nat,\n    });\n    const SupportedInterface = IDL.Variant({\n        'Burn': IDL.Null,\n        'Mint': IDL.Null,\n        'Approval': IDL.Null,\n        'TransactionHistory': IDL.Null,\n    });\n    const ManualReply_3 = IDL.Variant({ 'Ok': TokenMetadata, 'Err': NftError });\n    const TxEvent = IDL.Record({\n        'time': IDL.Nat64,\n        'operation': IDL.Text,\n        'details': IDL.Vec(IDL.Tuple(IDL.Text, GenericValue)),\n        'caller': IDL.Principal,\n    });\n    const ManualReply_4 = IDL.Variant({ 'Ok': TxEvent, 'Err': NftError });\n    return IDL.Service({\n        'approve': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),\n        'balanceOf': IDL.Func([IDL.Principal], [Result], ['query']),\n        'burn': IDL.Func([IDL.Nat], [Result], []),\n        'custodians': IDL.Func([], [IDL.Vec(IDL.Principal)], ['query']),\n        'cycles': IDL.Func([], [IDL.Nat], ['query']),\n        'isApprovedForAll': IDL.Func([IDL.Principal, IDL.Principal], [Result_1], ['query']),\n        'logo': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),\n        'metadata': IDL.Func([], [ManualReply], ['query']),\n        'mint': IDL.Func([IDL.Principal, IDL.Nat, IDL.Vec(IDL.Tuple(IDL.Text, GenericValue))], [Result], []),\n        'name': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),\n        'operatorOf': IDL.Func([IDL.Nat], [Result_2], ['query']),\n        'operatorTokenIdentifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),\n        'operatorTokenMetadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),\n        'ownerOf': IDL.Func([IDL.Nat], [Result_2], ['query']),\n        'ownerTokenIdentifiers': IDL.Func([IDL.Principal], [ManualReply_1], ['query']),\n        'ownerTokenMetadata': IDL.Func([IDL.Principal], [ManualReply_2], ['query']),\n        'setApprovalForAll': IDL.Func([IDL.Principal, IDL.Bool], [Result], []),\n        'setCustodians': IDL.Func([IDL.Vec(IDL.Principal)], [], []),\n        'setLogo': IDL.Func([IDL.Text], [], []),\n        'setName': IDL.Func([IDL.Text], [], []),\n        'setSymbol': IDL.Func([IDL.Text], [], []),\n        'stats': IDL.Func([], [Stats], ['query']),\n        'supportedInterfaces': IDL.Func([], [IDL.Vec(SupportedInterface)], ['query']),\n        'symbol': IDL.Func([], [IDL.Opt(IDL.Text)], ['query']),\n        'tokenMetadata': IDL.Func([IDL.Nat], [ManualReply_3], ['query']),\n        'totalSupply': IDL.Func([], [IDL.Nat], ['query']),\n        'totalTransactions': IDL.Func([], [IDL.Nat], ['query']),\n        'totalUniqueHolders': IDL.Func([], [IDL.Nat], ['query']),\n        'transaction': IDL.Func([IDL.Nat], [ManualReply_4], ['query']),\n        'transfer': IDL.Func([IDL.Principal, IDL.Nat], [Result], []),\n        'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [Result], []),\n    });\n};\nconst init = ({ IDL }) => {\n    const InitArgs = IDL.Record({\n        'logo': IDL.Opt(IDL.Text),\n        'name': IDL.Opt(IDL.Text),\n        'custodians': IDL.Opt(IDL.Vec(IDL.Principal)),\n        'symbol': IDL.Opt(IDL.Text),\n    });\n    return [IDL.Opt(InitArgs)];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/dip_721_v2.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/ext.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\n/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable camelcase */\nexports[\"default\"] = ({ IDL }) => {\n    const TokenIndex = IDL.Nat32;\n    const AccountIdentifier = IDL.Text;\n    const TokenIdentifier = IDL.Text;\n    const Balance = IDL.Nat;\n    const Time = IDL.Int;\n    const SubAccount = IDL.Vec(IDL.Nat8);\n    const Memo = IDL.Vec(IDL.Nat8);\n    const Listing = IDL.Record({\n        locked: IDL.Opt(Time),\n        seller: IDL.Principal,\n        price: IDL.Nat64,\n    });\n    const User = IDL.Variant({\n        principal: IDL.Principal,\n        address: AccountIdentifier,\n    });\n    const CommonError = IDL.Variant({\n        InvalidToken: TokenIdentifier,\n        Other: IDL.Text,\n    });\n    const BalanceRequest = IDL.Record({\n        token: TokenIdentifier,\n        user: User,\n    });\n    const BalanceResult = IDL.Variant({ ok: Balance, err: CommonError });\n    const DetailsResult = IDL.Variant({\n        ok: IDL.Tuple(AccountIdentifier, IDL.Opt(Listing)),\n        err: CommonError,\n    });\n    const TokensResult = IDL.Variant({\n        ok: IDL.Vec(TokenIndex),\n        err: CommonError,\n    });\n    const TokenExtResult = IDL.Variant({\n        ok: IDL.Vec(IDL.Tuple(TokenIndex, IDL.Opt(Listing), IDL.Opt(IDL.Vec(IDL.Nat8)))),\n        err: CommonError,\n    });\n    const TransferRequest = IDL.Record({\n        to: User,\n        token: TokenIdentifier,\n        notify: IDL.Bool,\n        from: User,\n        memo: Memo,\n        subaccount: IDL.Opt(SubAccount),\n        amount: Balance,\n        fee: IDL.Nat,\n    });\n    const TransferResult = IDL.Variant({\n        ok: Balance,\n        err: IDL.Variant({\n            CannotNotify: AccountIdentifier,\n            InsufficientBalance: IDL.Null,\n            InvalidToken: TokenIdentifier,\n            Rejected: IDL.Null,\n            Unauthorized: AccountIdentifier,\n            Other: IDL.Text,\n        }),\n    });\n    const Metadata = IDL.Variant({\n        fungible: IDL.Record({\n            decimals: IDL.Nat8,\n            metadata: IDL.Opt(IDL.Vec(IDL.Nat8)),\n            name: IDL.Text,\n            symbol: IDL.Text,\n        }),\n        nonfungible: IDL.Record({ metadata: IDL.Opt(IDL.Vec(IDL.Nat8)) }),\n    });\n    const MetadataResult = IDL.Variant({ ok: Metadata, err: CommonError });\n    const SupplyResult = IDL.Variant({ ok: Balance, err: CommonError });\n    return IDL.Service({\n        extensions: IDL.Func([], [IDL.Vec(IDL.Text)], ['query']),\n        balance: IDL.Func([BalanceRequest], [BalanceResult], ['query']),\n        details: IDL.Func([TokenIdentifier], [DetailsResult], ['query']),\n        tokens: IDL.Func([AccountIdentifier], [TokensResult], ['query']),\n        tokens_ext: IDL.Func([AccountIdentifier], [TokenExtResult], ['query']),\n        transfer: IDL.Func([TransferRequest], [TransferResult], []),\n        metadata: IDL.Func([TokenIdentifier], [MetadataResult], ['query']),\n        supply: IDL.Func([TokenIdentifier], [SupplyResult], ['query']),\n    });\n};\nconst init = () => {\n    return [];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/ext.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.init = void 0;\n/* eslint-disable camelcase */\n/* eslint-disable @typescript-eslint/camelcase */\nexports["default"] = ({ IDL }) => {\n    const Property = IDL.Record({ value: IDL.Text, name: IDL.Text });\n    const TokenDesc = IDL.Record({\n        id: IDL.Nat,\n        url: IDL.Text,\n        owner: IDL.Principal,\n        desc: IDL.Text,\n        name: IDL.Text,\n        properties: IDL.Vec(Property),\n    });\n    const TokenIndex = IDL.Nat;\n    const ICPunk = IDL.Service({\n        data_of: IDL.Func([TokenIndex], [TokenDesc], []),\n        transfer_to: IDL.Func([IDL.Principal, TokenIndex], [IDL.Bool], []),\n        user_tokens: IDL.Func([IDL.Principal], [IDL.Vec(IDL.Nat)], []),\n    });\n    return ICPunk;\n};\nconst init = ({ IDL }) => {\n    return [IDL.Text, IDL.Text, IDL.Nat, IDL.Principal];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js?')},"../../node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.init = void 0;\n/* eslint-disable @typescript-eslint/class-name-casing */\n/* eslint-disable camelcase */\n/* eslint-disable @typescript-eslint/camelcase */\nexports["default"] = ({ IDL }) => {\n    const AccountIdentifier = IDL.Text;\n    const Duration = IDL.Record({ secs: IDL.Nat64, nanos: IDL.Nat32 });\n    const ArchiveOptions = IDL.Record({\n        max_message_size_bytes: IDL.Opt(IDL.Nat32),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat32),\n        controller_id: IDL.Principal,\n    });\n    const ICPTs = IDL.Record({ e8s: IDL.Nat64 });\n    const LedgerCanisterInitPayload = IDL.Record({\n        send_whitelist: IDL.Vec(IDL.Tuple(IDL.Principal)),\n        minting_account: AccountIdentifier,\n        transaction_window: IDL.Opt(Duration),\n        max_message_size_bytes: IDL.Opt(IDL.Nat32),\n        archive_options: IDL.Opt(ArchiveOptions),\n        initial_values: IDL.Vec(IDL.Tuple(AccountIdentifier, ICPTs)),\n    });\n    const AccountBalanceArgs = IDL.Record({ account: AccountIdentifier });\n    const SubAccount = IDL.Vec(IDL.Nat8);\n    const BlockHeight = IDL.Nat64;\n    const NotifyCanisterArgs = IDL.Record({\n        to_subaccount: IDL.Opt(SubAccount),\n        from_subaccount: IDL.Opt(SubAccount),\n        to_canister: IDL.Principal,\n        max_fee: ICPTs,\n        block_height: BlockHeight,\n    });\n    const Memo = IDL.Nat64;\n    const TimeStamp = IDL.Record({ timestamp_nanos: IDL.Nat64 });\n    const SendArgs = IDL.Record({\n        to: AccountIdentifier,\n        fee: ICPTs,\n        memo: Memo,\n        from_subaccount: IDL.Opt(SubAccount),\n        created_at_time: IDL.Opt(TimeStamp),\n        amount: ICPTs,\n    });\n    return IDL.Service({\n        account_balance_dfx: IDL.Func([AccountBalanceArgs], [ICPTs], [\'query\']),\n        notify_dfx: IDL.Func([NotifyCanisterArgs], [], []),\n        send_dfx: IDL.Func([SendArgs], [BlockHeight], []),\n    });\n};\nconst init = ({ IDL }) => {\n    const AccountIdentifier = IDL.Text;\n    const Duration = IDL.Record({ secs: IDL.Nat64, nanos: IDL.Nat32 });\n    const ArchiveOptions = IDL.Record({\n        max_message_size_bytes: IDL.Opt(IDL.Nat32),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat32),\n        controller_id: IDL.Principal,\n    });\n    const ICPTs = IDL.Record({ e8s: IDL.Nat64 });\n    const LedgerCanisterInitPayload = IDL.Record({\n        send_whitelist: IDL.Vec(IDL.Tuple(IDL.Principal)),\n        minting_account: AccountIdentifier,\n        transaction_window: IDL.Opt(Duration),\n        max_message_size_bytes: IDL.Opt(IDL.Nat32),\n        archive_options: IDL.Opt(ArchiveOptions),\n        initial_values: IDL.Vec(IDL.Tuple(AccountIdentifier, ICPTs)),\n    });\n    return [LedgerCanisterInitPayload];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js?')},"../../node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const TxError = IDL.Variant({\n        'InsufficientAllowance': IDL.Null,\n        'InsufficientBalance': IDL.Null,\n        'ErrorOperationStyle': IDL.Null,\n        'Unauthorized': IDL.Null,\n        'LedgerTrap': IDL.Null,\n        'ErrorTo': IDL.Null,\n        'Other': IDL.Null,\n        'BlockUsed': IDL.Null,\n        'AmountTooSmall': IDL.Null,\n    });\n    const TxReceipt = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });\n    const Metadata = IDL.Record({\n        'fee': IDL.Nat,\n        'decimals': IDL.Nat8,\n        'owner': IDL.Principal,\n        'logo': IDL.Text,\n        'name': IDL.Text,\n        'totalSupply': IDL.Nat,\n        'symbol': IDL.Text,\n    });\n    const TokenInfo = IDL.Record({\n        'holderNumber': IDL.Nat64,\n        'deployTime': IDL.Nat64,\n        'metadata': Metadata,\n        'historySize': IDL.Nat64,\n        'cycles': IDL.Nat64,\n        'feeTo': IDL.Principal,\n    });\n    return IDL.Service({\n        'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),\n        'approve': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),\n        'decimals': IDL.Func([], [IDL.Nat8], ['query']),\n        'getAllowanceSize': IDL.Func([], [IDL.Nat64], ['query']),\n        'getHolders': IDL.Func([IDL.Nat64, IDL.Nat64], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),\n        'getLogo': IDL.Func([], [IDL.Text], ['query']),\n        'getMetadata': IDL.Func([], [Metadata], ['query']),\n        'getTokenInfo': IDL.Func([], [TokenInfo], ['query']),\n        'getUserApprovals': IDL.Func([IDL.Principal], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ['query']),\n        'historySize': IDL.Func([], [IDL.Nat64], ['query']),\n        'mint': IDL.Func([IDL.Opt(IDL.Vec(IDL.Nat8)), IDL.Nat64], [TxReceipt], []),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'owner': IDL.Func([], [IDL.Principal], ['query']),\n        'setFee': IDL.Func([IDL.Nat], [], []),\n        'setFeeTo': IDL.Func([IDL.Principal], [], []),\n        'setLogo': IDL.Func([IDL.Text], [], []),\n        'setName': IDL.Func([IDL.Text], [], []),\n        'setOwner': IDL.Func([IDL.Principal], [], []),\n        'symbol': IDL.Func([], [IDL.Text], ['query']),\n        'totalSupply': IDL.Func([], [IDL.Nat], ['query']),\n        'transfer': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'withdraw': IDL.Func([IDL.Nat64, IDL.Text], [TxReceipt], []),\n    });\n};\nconst init = ({ IDL }) => {\n    return [\n        IDL.Text,\n        IDL.Text,\n        IDL.Text,\n        IDL.Nat8,\n        IDL.Nat,\n        IDL.Principal,\n        IDL.Nat,\n        IDL.Principal,\n        IDL.Principal,\n    ];\n};\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js":function(__unused_webpack_module,exports){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports[\"default\"] = ({ IDL }) => {\n    const TxError = IDL.Variant({\n        'InsufficientAllowance': IDL.Null,\n        'InsufficientBalance': IDL.Null,\n        'ErrorOperationStyle': IDL.Null,\n        'Unauthorized': IDL.Null,\n        'LedgerTrap': IDL.Null,\n        'ErrorTo': IDL.Null,\n        'Other': IDL.Null,\n        'BlockUsed': IDL.Null,\n        'AmountTooSmall': IDL.Null,\n    });\n    const TxReceipt = IDL.Variant({ 'Ok': IDL.Nat, 'Err': TxError });\n    const TransactionId = IDL.Nat64;\n    const BurnError = IDL.Variant({\n        'InsufficientBalance': IDL.Null,\n        'InvalidTokenContract': IDL.Null,\n        'NotSufficientLiquidity': IDL.Null,\n    });\n    const BurnResult = IDL.Variant({ 'Ok': TransactionId, 'Err': BurnError });\n    const TransactionStatus = IDL.Variant({\n        'FAILED': IDL.Null,\n        'SUCCEEDED': IDL.Null,\n    });\n    const EventDetail = IDL.Variant({\n        'Approve': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),\n        'Burn': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),\n        'Mint': IDL.Record({ 'to': IDL.Principal }),\n        'CanisterCreated': IDL.Record({\n            'from': IDL.Principal,\n            'canister': IDL.Principal,\n        }),\n        'CanisterCalled': IDL.Record({\n            'from': IDL.Principal,\n            'method_name': IDL.Text,\n            'canister': IDL.Principal,\n        }),\n        'Transfer': IDL.Record({ 'to': IDL.Principal, 'from': IDL.Principal }),\n        'TransferFrom': IDL.Record({\n            'to': IDL.Principal,\n            'from': IDL.Principal,\n            'caller': IDL.Principal,\n        }),\n    });\n    const Event = IDL.Record({\n        'fee': IDL.Nat64,\n        'status': TransactionStatus,\n        'kind': EventDetail,\n        'cycles': IDL.Nat64,\n        'timestamp': IDL.Nat64,\n    });\n    const EventsConnection = IDL.Record({\n        'data': IDL.Vec(Event),\n        'next_offset': TransactionId,\n        'next_canister_id': IDL.Opt(IDL.Principal),\n    });\n    const Metadata = IDL.Record({\n        'fee': IDL.Nat,\n        'decimals': IDL.Nat8,\n        'owner': IDL.Principal,\n        'logo': IDL.Text,\n        'name': IDL.Text,\n        'totalSupply': IDL.Nat,\n        'symbol': IDL.Text,\n    });\n    const Operation = IDL.Variant({\n        'transferFrom': IDL.Null,\n        'burn': IDL.Null,\n        'mint': IDL.Null,\n        'approve': IDL.Null,\n        'canisterCalled': IDL.Null,\n        'transfer': IDL.Null,\n        'canisterCreated': IDL.Null,\n    });\n    const Time = IDL.Int;\n    const TxRecord = IDL.Record({\n        'op': Operation,\n        'to': IDL.Principal,\n        'fee': IDL.Nat,\n        'status': TransactionStatus,\n        'from': IDL.Principal,\n        'timestamp': Time,\n        'caller': IDL.Opt(IDL.Principal),\n        'index': IDL.Nat,\n        'amount': IDL.Nat,\n    });\n    const MintError = IDL.Variant({ 'NotSufficientLiquidity': IDL.Null });\n    const MintResult = IDL.Variant({ 'Ok': TransactionId, 'Err': MintError });\n    const Stats = IDL.Record({\n        'fee': IDL.Nat,\n        'transfers_count': IDL.Nat64,\n        'balance': IDL.Nat64,\n        'mints_count': IDL.Nat64,\n        'transfers_from_count': IDL.Nat64,\n        'canisters_created_count': IDL.Nat64,\n        'supply': IDL.Nat,\n        'burns_count': IDL.Nat64,\n        'approvals_count': IDL.Nat64,\n        'proxy_calls_count': IDL.Nat64,\n        'history_events': IDL.Nat64,\n    });\n    const ResultCall = IDL.Variant({\n        'Ok': IDL.Record({ 'return': IDL.Vec(IDL.Nat8) }),\n        'Err': IDL.Text,\n    });\n    const CreateResult = IDL.Variant({\n        'Ok': IDL.Record({ 'canister_id': IDL.Principal }),\n        'Err': IDL.Text,\n    });\n    const ResultSend = IDL.Variant({ 'Ok': IDL.Null, 'Err': IDL.Text });\n    return IDL.Service({\n        'allowance': IDL.Func([IDL.Principal, IDL.Principal], [IDL.Nat], ['query']),\n        'approve': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'balance': IDL.Func([IDL.Opt(IDL.Principal)], [IDL.Nat64], []),\n        'balanceOf': IDL.Func([IDL.Principal], [IDL.Nat], ['query']),\n        'burn': IDL.Func([IDL.Record({ 'canister_id': IDL.Principal, 'amount': IDL.Nat64 })], [BurnResult], []),\n        'decimals': IDL.Func([], [IDL.Nat8], ['query']),\n        'events': IDL.Func([IDL.Record({ 'offset': IDL.Opt(IDL.Nat64), 'limit': IDL.Nat16 })], [EventsConnection], ['query']),\n        'getMetadata': IDL.Func([], [Metadata], ['query']),\n        'getTransaction': IDL.Func([IDL.Nat], [TxRecord], []),\n        'getTransactions': IDL.Func([IDL.Nat, IDL.Nat], [IDL.Vec(TxRecord)], []),\n        'get_transaction': IDL.Func([TransactionId], [IDL.Opt(Event)], []),\n        'halt': IDL.Func([], [], []),\n        'historySize': IDL.Func([], [IDL.Nat], ['query']),\n        'logo': IDL.Func([], [IDL.Text], ['query']),\n        'mint': IDL.Func([IDL.Principal, IDL.Nat], [MintResult], []),\n        'name': IDL.Func([], [IDL.Text], ['query']),\n        'nameErc20': IDL.Func([], [IDL.Text], ['query']),\n        'stats': IDL.Func([], [Stats], ['query']),\n        'symbol': IDL.Func([], [IDL.Text], ['query']),\n        'totalSupply': IDL.Func([], [IDL.Nat], ['query']),\n        'transfer': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'transferErc20': IDL.Func([IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'transferFrom': IDL.Func([IDL.Principal, IDL.Principal, IDL.Nat], [TxReceipt], []),\n        'wallet_balance': IDL.Func([], [IDL.Record({ 'amount': IDL.Nat64 })], ['query']),\n        'wallet_call': IDL.Func([\n            IDL.Record({\n                'args': IDL.Vec(IDL.Nat8),\n                'cycles': IDL.Nat64,\n                'method_name': IDL.Text,\n                'canister': IDL.Principal,\n            }),\n        ], [ResultCall], []),\n        'wallet_create_canister': IDL.Func([\n            IDL.Record({\n                'controller': IDL.Opt(IDL.Principal),\n                'cycles': IDL.Nat64,\n            }),\n        ], [CreateResult], []),\n        'wallet_create_wallet': IDL.Func([\n            IDL.Record({\n                'controller': IDL.Opt(IDL.Principal),\n                'cycles': IDL.Nat64,\n            }),\n        ], [CreateResult], []),\n        'wallet_send': IDL.Func([IDL.Record({ 'canister': IDL.Principal, 'amount': IDL.Nat64 })], [ResultSend], []),\n    });\n};\nconst init = () => { return []; };\nexports.init = init;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js?")},"../../node_modules/@psychedelic/dab-js/dist/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.standards = exports.TokenInterfaces = exports.NFTInterfaces = void 0;\n__exportStar(__webpack_require__(/*! ./registries */ "../../node_modules/@psychedelic/dab-js/dist/registries/index.js"), exports);\n__exportStar(__webpack_require__(/*! ./interfaces/nft */ "../../node_modules/@psychedelic/dab-js/dist/interfaces/nft.js"), exports);\n__exportStar(__webpack_require__(/*! ./interfaces/token */ "../../node_modules/@psychedelic/dab-js/dist/interfaces/token.js"), exports);\nexports.NFTInterfaces = __importStar(__webpack_require__(/*! ./interfaces/nft */ "../../node_modules/@psychedelic/dab-js/dist/interfaces/nft.js"));\nexports.TokenInterfaces = __importStar(__webpack_require__(/*! ./interfaces/token */ "../../node_modules/@psychedelic/dab-js/dist/interfaces/token.js"));\nvar standards_1 = __webpack_require__(/*! ./constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nObject.defineProperty(exports, "standards", ({ enumerable: true, get: function () { return __importDefault(standards_1).default; } }));\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/index.js?')},"../../node_modules/@psychedelic/dab-js/dist/interfaces/nft.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/interfaces/nft.js?')},"../../node_modules/@psychedelic/dab-js/dist/interfaces/token.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/interfaces/token.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/address_book.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.removeAddress = exports.addAddress = exports.getAddresses = exports.getAddressBookActor = void 0;\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst address_book_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/address_book.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/address_book.did.js"));\nconst CANISTER_ID = \'i73cm-daaaa-aaaah-abhea-cai\';\nconst getAddressBookActor = (agent) => {\n    const actor = agent_1.Actor.createActor(address_book_did_1.default, { agent, canisterId: CANISTER_ID });\n    return actor;\n};\nexports.getAddressBookActor = getAddressBookActor;\nconst getAddresses = (agent) => __awaiter(void 0, void 0, void 0, function* () {\n    const actor = (0, exports.getAddressBookActor)(agent);\n    const addresses = yield actor.get_all();\n    return addresses.map(address => ({\n        name: address.name,\n        description: address.description,\n        emoji: address.emoji,\n        value: address.value,\n    }));\n});\nexports.getAddresses = getAddresses;\nconst addAddress = (agent, newAddress) => __awaiter(void 0, void 0, void 0, function* () {\n    const actor = (0, exports.getAddressBookActor)(agent);\n    const addResponse = yield actor.add({\n        name: newAddress.name,\n        description: newAddress.description,\n        emoji: newAddress.emoji,\n        value: newAddress.value,\n    });\n    return addResponse;\n});\nexports.addAddress = addAddress;\nconst removeAddress = (agent, addressName) => __awaiter(void 0, void 0, void 0, function* () {\n    const actor = (0, exports.getAddressBookActor)(agent);\n    const removeResponse = yield actor.remove(addressName);\n    return removeResponse;\n});\nexports.removeAddress = removeAddress;\nexports["default"] = {\n    getAddressBookActor: exports.getAddressBookActor,\n    getAddresses: exports.getAddresses,\n    addAddress: exports.addAddress,\n    removeAddress: exports.removeAddress,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/address_book.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getAll = exports.getMultipleCanisterInfo = exports.getCanisterInfo = exports.CanisterRegistry = void 0;\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "../../node_modules/cross-fetch/dist/browser-ponyfill.js"));\nconst canister_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/canister_registry.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/canister_registry.did.js"));\nconst constants_1 = __webpack_require__(/*! ../constants */ "../../node_modules/@psychedelic/dab-js/dist/constants/index.js");\nconst standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));\nconst actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");\nconst registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@psychedelic/dab-js/dist/utils/registry.js");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst CANISTER_ID = \'curr3-vaaaa-aaaah-abbdq-cai\';\nconst DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });\nconst formatBackwardsCompatible = (metadata) => {\n    if (!metadata) {\n        return metadata;\n    }\n    const { thumbnail, name, description, frontend, details } = metadata;\n    return { url: (frontend === null || frontend === void 0 ? void 0 : frontend[0]) || \'\', name, description, version: Number(details.version), logo_url: thumbnail };\n};\nclass CanisterRegistry extends standard_registry_1.default {\n    constructor(agent) {\n        super(CANISTER_ID, agent);\n        this.getAll = () => __awaiter(this, void 0, void 0, function* () {\n            const canistersMetadata = yield this.actor.get_all();\n            return canistersMetadata.map(registry_1.formatMetadata);\n        });\n        this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT, canisterId: CANISTER_ID, IDL: canister_registry_did_1.default });\n    }\n}\nexports.CanisterRegistry = CanisterRegistry;\nconst getCanisterInfo = ({ canisterId, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {\n    const canisterRegistry = new CanisterRegistry(agent);\n    const canister = yield canisterRegistry.get(principal_1.Principal.from(canisterId).toString());\n    return formatBackwardsCompatible(canister);\n});\nexports.getCanisterInfo = getCanisterInfo;\nconst getMultipleCanisterInfo = ({ canisterIds, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {\n    const canistersMetadata = yield Promise.all(canisterIds.map((canisterId) => (0, exports.getCanisterInfo)({ canisterId, agent })));\n    if (canistersMetadata.length === 0)\n        return [];\n    return canistersMetadata.filter(canister => !!canister);\n});\nexports.getMultipleCanisterInfo = getMultipleCanisterInfo;\nconst getAll = (agent) => __awaiter(void 0, void 0, void 0, function* () {\n    const allCanisters = yield new CanisterRegistry(agent).getAll();\n    return allCanisters.map(formatBackwardsCompatible);\n});\nexports.getAll = getAll;\nexports["default"] = {\n    getCanisterInfo: exports.getCanisterInfo,\n    getMultipleCanisterInfo: exports.getMultipleCanisterInfo,\n    getAll: (agent) => new CanisterRegistry(agent).getAll,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./nfts_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js"), exports);\n__exportStar(__webpack_require__(/*! ./canister_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/canister_registry.js"), exports);\n__exportStar(__webpack_require__(/*! ./token_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/token_registry.js"), exports);\n__exportStar(__webpack_require__(/*! ./address_book */ "../../node_modules/@psychedelic/dab-js/dist/registries/address_book.js"), exports);\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/index.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getCachedUserNFTs = exports.getBatchedNFTs = exports.getAllUserNFTs = exports.getAllNFTS = exports.getNFTInfo = exports.getNFTActor = exports.getUserCollectionTokens = exports.NFTRegistry = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/index.js"));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "../../node_modules/cross-fetch/dist/browser-ponyfill.js"));\nconst ext_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ext */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js"));\nconst ic_punks_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ic_punks */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js"));\nconst departure_labs_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/departure_labs */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js"));\nconst dip_721_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/dip_721 */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js"));\nconst dip_721_v2_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/dip_721_v2 */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721_v2.js"));\nconst standards_1 = __webpack_require__(/*! ../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst constants_1 = __webpack_require__(/*! ../constants */ "../../node_modules/@psychedelic/dab-js/dist/constants/index.js");\nconst nft_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/nft_registry.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/nft_registry.did.js"));\nconst standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));\nconst actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");\nconst registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@psychedelic/dab-js/dist/utils/registry.js");\nconst ccc_1 = __importDefault(__webpack_require__(/*! ../standard_wrappers/nft_standards/ccc */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js"));\nconst CANISTER_ID = \'ctqxp-yyaaa-aaaah-abbda-cai\';\nconst BATCH_AMOUNT = 5;\nconst NFT_STANDARDS = {\n    [standards_1.NFT.ext]: ext_1.default,\n    [standards_1.NFT.icpunks]: ic_punks_1.default,\n    [standards_1.NFT.departuresLabs]: departure_labs_1.default,\n    [standards_1.NFT.erc721]: dip_721_1.default,\n    [standards_1.NFT.dip721]: dip_721_1.default,\n    [standards_1.NFT.dip721v2]: dip_721_v2_1.default,\n    [standards_1.NFT.c3]: ccc_1.default\n};\nconst DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });\nclass NFTRegistry extends standard_registry_1.default {\n    constructor(agent) {\n        super(CANISTER_ID, agent);\n        this.getAll = () => __awaiter(this, void 0, void 0, function* () {\n            const canistersMetadata = yield this.actor.get_all();\n            return canistersMetadata.map(registry_1.formatMetadata);\n        });\n        this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT, canisterId: CANISTER_ID, IDL: nft_registry_did_1.default });\n    }\n}\nexports.NFTRegistry = NFTRegistry;\nconst getUserCollectionTokens = (collection, user, agent = DEFAULT_AGENT, callback = () => { }) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const NFTActor = (0, exports.getNFTActor)({\n            canisterId: collection.principal_id.toString(),\n            agent,\n            standard: collection.standard\n        });\n        const details = yield NFTActor.getUserTokens(user);\n        const collectionDetails = {\n            name: collection.name,\n            canisterId: collection.principal_id.toString(),\n            standard: collection.standard,\n            description: collection.description,\n            icon: collection.icon,\n            tokens: details.map((detail) => (Object.assign(Object.assign({}, detail), { collection: collection.name }))),\n        };\n        if (callback) {\n            yield (callback === null || callback === void 0 ? void 0 : callback(collectionDetails));\n        }\n        return collectionDetails;\n    }\n    catch (e) {\n        console.error(e);\n        return {\n            name: collection.name,\n            canisterId: collection.principal_id.toString(),\n            standard: collection.standard,\n            tokens: [],\n        };\n    }\n});\nexports.getUserCollectionTokens = getUserCollectionTokens;\nconst getNFTActor = ({ canisterId, agent, standard }) => {\n    if (!(standard in NFT_STANDARDS)) {\n        console.error(`Standard ${standard} is not implemented`);\n        throw new Error(`standard is not supported: ${standard}`);\n    }\n    return new NFT_STANDARDS[standard](canisterId, agent);\n};\nexports.getNFTActor = getNFTActor;\nconst getNFTInfo = ({ nftCanisterId, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {\n    const registry = new NFTRegistry(agent);\n    const result = yield registry.get(nftCanisterId);\n    if (!result)\n        return result;\n    return Object.assign(Object.assign({}, result), { icon: result.thumbnail, standard: result.details.standard });\n});\nexports.getNFTInfo = getNFTInfo;\nconst getAllNFTS = ({ agent = DEFAULT_AGENT } = {}) => __awaiter(void 0, void 0, void 0, function* () {\n    const registry = new NFTRegistry(agent);\n    const allNFTs = yield registry.getAll();\n    return allNFTs.map((nft) => (Object.assign(Object.assign({}, nft), { icon: nft.thumbnail, standard: nft.details.standard })));\n});\nexports.getAllNFTS = getAllNFTS;\nconst getAllUserNFTs = ({ user, agent = DEFAULT_AGENT }) => __awaiter(void 0, void 0, void 0, function* () {\n    const NFTCollections = yield (0, exports.getAllNFTS)({ agent });\n    const userPrincipal = user instanceof principal_1.Principal ? user : principal_1.Principal.fromText(user);\n    const result = yield Promise.all(NFTCollections.map((collection) => (0, exports.getUserCollectionTokens)(collection, userPrincipal, agent)));\n    return result.filter((element) => element.tokens.length);\n});\nexports.getAllUserNFTs = getAllUserNFTs;\nconst getBatchedNFTs = ({ principal, callback, batchSize = BATCH_AMOUNT, onFinish, agent = DEFAULT_AGENT, }) => __awaiter(void 0, void 0, void 0, function* () {\n    const NFTCollections = yield (0, exports.getAllNFTS)({ agent });\n    let result = [];\n    for (let i = 0; i < NFTCollections.length; i += batchSize) {\n        const batch = NFTCollections.slice(i, i + batchSize);\n        const batchResult = yield Promise.all(batch.map(collection => (0, exports.getUserCollectionTokens)(collection, principal, agent, callback)));\n        result = [...result, ...batchResult];\n    }\n    if (onFinish) {\n        yield (onFinish === null || onFinish === void 0 ? void 0 : onFinish(result));\n    }\n    return result.filter((element) => { var _a; return (_a = element === null || element === void 0 ? void 0 : element.tokens) === null || _a === void 0 ? void 0 : _a.length; });\n});\nexports.getBatchedNFTs = getBatchedNFTs;\nconst getCachedUserNFTs = ({ userPID, refresh }) => __awaiter(void 0, void 0, void 0, function* () {\n    const url = `${constants_1.KYASSHU_URL}/dab/user/nfts/${userPID}${refresh ? \'?refresh=true\' : \'\'}`;\n    const result = yield axios_1.default.get(url);\n    if (!refresh)\n        axios_1.default.get(`${url}?refresh=true`).catch(console.warn);\n    return result.data;\n});\nexports.getCachedUserNFTs = getCachedUserNFTs;\nexports["default"] = {\n    getBatchedNFTs: exports.getBatchedNFTs,\n    getNFTActor: exports.getNFTActor,\n    getNFTInfo: exports.getNFTInfo,\n    getAllNFTS: exports.getAllNFTS,\n    getAllUserNFTs: exports.getAllUserNFTs,\n    getCachedUserNFTs: exports.getCachedUserNFTs,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/nfts_registry.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst constants_1 = __webpack_require__(/*! ../constants */ "../../node_modules/@psychedelic/dab-js/dist/constants/index.js");\nconst registry_standard_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/registry_standard.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/registry_standard.did.js"));\nconst registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@psychedelic/dab-js/dist/utils/registry.js");\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "../../node_modules/cross-fetch/dist/browser-ponyfill.js"));\nconst DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });\nclass Registry {\n    constructor(canisterId, agent = DEFAULT_AGENT) {\n        this.name = () => __awaiter(this, void 0, void 0, function* () {\n            return this.actor.name();\n        });\n        this.add = (metadata) => __awaiter(this, void 0, void 0, function* () {\n            return this.actor.add(metadata !== null && metadata !== void 0 ? metadata : []);\n        });\n        this.get = (principalId) => __awaiter(this, void 0, void 0, function* () {\n            const data = yield this.actor.get(principal_1.Principal.fromText(principalId));\n            if (data.length === 0)\n                return undefined;\n            return (0, registry_1.formatMetadata)(data[0]);\n        });\n        this.remove = (principalId) => __awaiter(this, void 0, void 0, function* () {\n            return this.actor.remove(principal_1.Principal.fromText(principalId));\n        });\n        this.actor = agent_1.Actor.createActor(registry_standard_did_1.default, {\n            agent: agent,\n            canisterId,\n        });\n        this.canisterId = canisterId;\n    }\n}\nexports["default"] = Registry;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js?')},"../../node_modules/@psychedelic/dab-js/dist/registries/token_registry.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getTokens = exports.TokenRegistry = exports.getTokenActor = exports.TOKEN_STANDARDS = void 0;\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ "../../node_modules/cross-fetch/dist/browser-ponyfill.js"));\nconst token_registry_did_1 = __importDefault(__webpack_require__(/*! ../idls/dab_registries/token_registry.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dab_registries/token_registry.did.js"));\nconst standard_registry_1 = __importDefault(__webpack_require__(/*! ./standard_registry */ "../../node_modules/@psychedelic/dab-js/dist/registries/standard_registry.js"));\nconst actorFactory_1 = __webpack_require__(/*! ../utils/actorFactory */ "../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");\nconst registry_1 = __webpack_require__(/*! ../utils/registry */ "../../node_modules/@psychedelic/dab-js/dist/utils/registry.js");\nconst constants_1 = __webpack_require__(/*! ../constants */ "../../node_modules/@psychedelic/dab-js/dist/constants/index.js");\nconst token_standards_1 = __webpack_require__(/*! ../standard_wrappers/token_standards */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js");\nconst standards_1 = __webpack_require__(/*! ../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst CANISTER_ID = \'b7hhy-tyaaa-aaaah-abbja-cai\';\nconst DEFAULT_AGENT = new agent_1.HttpAgent({ fetch: cross_fetch_1.default, host: constants_1.IC_HOST });\nexports.TOKEN_STANDARDS = Object.values(standards_1.TOKEN);\nconst getTokenActor = ({ canisterId, agent, standard, }) => {\n    if (!exports.TOKEN_STANDARDS.includes(standard)) {\n        console.error(`Standard ${standard} is not implemented`);\n        throw new Error(`standard is not supported: ${standard}`);\n    }\n    return (0, token_standards_1.createTokenActor)(canisterId, agent, standard);\n};\nexports.getTokenActor = getTokenActor;\nclass TokenRegistry extends standard_registry_1.default {\n    constructor(agent) {\n        super(CANISTER_ID, agent);\n        this.getAll = () => __awaiter(this, void 0, void 0, function* () {\n            const tokenCanistersMetadata = yield this.actor.get_all();\n            return tokenCanistersMetadata.map(registry_1.formatMetadata);\n        });\n        this.actor = (0, actorFactory_1.generateActor)({\n            agent: agent || DEFAULT_AGENT,\n            canisterId: CANISTER_ID,\n            IDL: token_registry_did_1.default,\n        });\n    }\n}\nexports.TokenRegistry = TokenRegistry;\nconst getTokens = ({ agent = DEFAULT_AGENT } = {}) => __awaiter(void 0, void 0, void 0, function* () {\n    const tokenRegistry = new TokenRegistry(agent);\n    const tokenCanisters = yield tokenRegistry.getAll();\n    return tokenCanisters.map((token) => (Object.assign(Object.assign({}, token), { logo: token.thumbnail, name: token.name, description: token.description, website: token.frontend.length ? token.frontend[0] : \'\', principal_id: token.principal_id, standard: token.details.standard, total_supply: [token.details.total_supply], symbol: token.details.symbol })));\n});\nexports.getTokens = getTokens;\nexports["default"] = {\n    getTokenActor: exports.getTokenActor,\n    getTokens: exports.getTokens,\n    addToken: ({ agent, tokenInfo }) => __awaiter(void 0, void 0, void 0, function* () { return new TokenRegistry(agent).add(tokenInfo); }),\n    // editToken: async ({ agent, tokenInfo }) => new TokenRegistry(agent).edit(tokenInfo),\n    removeToken: ({ agent, canisterId }) => __awaiter(void 0, void 0, void 0, function* () { return new TokenRegistry(agent).remove(canisterId); }),\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/registries/token_registry.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst c3_did_1 = __importDefault(__webpack_require__(/*! ../../idls/c3.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/c3.did.js"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nclass CCC extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.c3;\n        this.serializeTokenData = (tokenData, prinId) => {\n            return {\n                index: BigInt(tokenData.id),\n                canister: this.canisterId,\n                url: `https://${prinId.toText()}.raw.ic0.app/token/${tokenData.id}`,\n                name: `${tokenData.id}`,\n                metadata: tokenData,\n                standard: this.standard,\n            };\n        };\n        this.actor = agent_1.Actor.createActor(c3_did_1.default, {\n            agent,\n            canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokensIndexes = yield this.actor.getAllNFT(principal);\n            const tokensData = yield Promise.all(tokensIndexes.map((item) => __awaiter(this, void 0, void 0, function* () {\n                const tokenIndex = item[0];\n                const principal = item[1];\n                const userTokensResult = yield this.actor.getTokenById(tokenIndex);\n                if (\'err\' in userTokensResult)\n                    throw new Error(Object.keys(userTokensResult.err)[0]);\n                return { detail: userTokensResult.ok, principal };\n            })));\n            return tokensData.map((token) => this.serializeTokenData(token.detail, token.principal));\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const from = yield this.agent.getPrincipal();\n            const transferResult = yield this.actor.transferFrom(from, to, BigInt(tokenIndex));\n            if (\'err\' in transferResult)\n                throw new Error(Object.keys(transferResult.err)[0]);\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenData = yield this.actor.getTokenById(BigInt(tokenIndex));\n            if (\'err\' in tokenData)\n                throw new Error(Object.keys(tokenData.err)[0]);\n            const prinId = yield this.actor.getNftStoreCIDByIndex(BigInt(tokenIndex));\n            if (!prinId)\n                throw new Error(\'Error tokenIndex\');\n            return this.serializeTokenData(tokenData.ok, prinId);\n        });\n    }\n}\nexports["default"] = CCC;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ccc.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nclass NFT {\n    constructor(canisterId, agent) {\n        this.agent = agent;\n        this.canisterId = canisterId;\n    }\n}\nexports["default"] = NFT;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst departure_labs_did_1 = __importDefault(__webpack_require__(/*! ../../idls/departure_labs.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/departure_labs.did.js"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nclass DepartureLabs extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.departuresLabs;\n        this.serializeTokenData = (tokenData) => ({\n            index: BigInt(tokenData.id),\n            canister: this.canisterId,\n            url: `https://${this.canisterId}.raw.ic0.app/nft/${tokenData.id}`,\n            metadata: tokenData,\n            standard: this.standard,\n        });\n        this.actor = agent_1.Actor.createActor(departure_labs_did_1.default, {\n            agent,\n            canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokensIndexes = yield this.actor.balanceOf(principal);\n            const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => __awaiter(this, void 0, void 0, function* () {\n                const userTokensResult = yield this.actor.tokenMetadataByIndex(tokenIndex);\n                if (\'err\' in userTokensResult)\n                    throw new Error(Object.keys(userTokensResult.err)[0]);\n                return userTokensResult.ok;\n            })));\n            return tokensData.map((token) => this.serializeTokenData(token));\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transferResult = yield this.actor.transfer(to, tokenIndex.toString(10));\n            if (\'err\' in transferResult)\n                throw new Error(Object.keys(transferResult.err)[0]);\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenData = yield this.actor.tokenMetadataByIndex(tokenIndex.toString(10));\n            if (\'err\' in tokenData)\n                throw new Error(Object.keys(tokenData.err)[0]);\n            return this.serializeTokenData(tokenData.ok);\n        });\n    }\n}\nexports["default"] = DepartureLabs;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/departure_labs.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst dip_721_did_1 = __importDefault(__webpack_require__(/*! ../../idls/dip_721.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dip_721.did.js"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst extractMetadataValue = (metadata) => {\n    const metadataKey = Object.keys(metadata)[0];\n    const value = metadata[metadataKey];\n    return typeof value === \'object\' ? JSON.stringify(value) : value;\n};\nclass ERC721 extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.dip721;\n        this.actor = agent_1.Actor.createActor(dip_721_did_1.default, {\n            agent, canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const userTokensResult = yield this.actor.getMetadataForUserDip721(principal);\n            const tokens = userTokensResult || [];\n            return tokens.map((token) => {\n                const tokenIndex = token.token_id;\n                const formatedMetadata = this.formatMetadata(token.metadata_desc);\n                return this.serializeTokenData(formatedMetadata, tokenIndex);\n            });\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const from = yield this.agent.getPrincipal();\n            const transferResult = yield this.actor.transferFromDip721(from, to, BigInt(tokenIndex));\n            if (\'Err\' in transferResult)\n                throw new Error(`${Object.keys(transferResult.Err)[0]}: ${Object.values(transferResult.Err)[0]}`);\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const metadataResult = yield this.actor.getMetadataDip721(BigInt(tokenIndex));\n            if (\'Err\' in metadataResult)\n                throw new Error(`${Object.keys(metadataResult.Err)[0]}: ${Object.values(metadataResult.Err)[0]}`);\n            const metadata = metadataResult.Ok;\n            const formatedMetadata = this.formatMetadata(metadata);\n            return this.serializeTokenData(formatedMetadata, tokenIndex);\n        });\n    }\n    serializeTokenData(metadata, tokenIndex) {\n        var _a, _b;\n        return {\n            index: BigInt(tokenIndex),\n            canister: this.canisterId,\n            metadata,\n            url: ((_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.location) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.TextContent) || \'\',\n            standard: this.standard,\n        };\n    }\n    formatMetadata(metadata) {\n        const metadataResult = { properties: [] };\n        for (const part of metadata) {\n            const purpose = Object.keys(part.purpose)[0];\n            part.key_val_data.forEach(({ key, val }) => {\n                metadataResult[key] = { value: val, purpose };\n                metadataResult.properties = [...metadataResult.properties, { name: key, value: extractMetadataValue(val) }];\n            });\n        }\n        metadataResult.properties = metadataResult.properties.filter(({ name }) => name !== \'location\');\n        return metadataResult;\n    }\n}\nexports["default"] = ERC721;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721_v2.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ \"../../node_modules/@dfinity/agent/lib/esm/index.js\");\nconst dip_721_v2_did_1 = __importDefault(__webpack_require__(/*! ../../idls/dip_721_v2.did */ \"../../node_modules/@psychedelic/dab-js/dist/idls/dip_721_v2.did.js\"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ \"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js\"));\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ \"../../node_modules/@psychedelic/dab-js/dist/constants/standards.js\");\nconst extractMetadataValue = (metadata) => {\n    const metadataKey = Object.keys(metadata)[0];\n    const value = metadata[metadataKey];\n    return typeof value === 'object' ? JSON.stringify(value) : value;\n};\nclass ERC721 extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.dip721v2;\n        this.actor = agent_1.Actor.createActor(dip_721_v2_did_1.default, {\n            agent,\n            canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const userTokensResult = yield this.actor.ownerTokenMetadata(principal);\n            const tokens = userTokensResult['Ok'] || [];\n            return tokens.map((token) => {\n                const tokenIndex = token.token_identifier;\n                const formatedMetadata = this.formatMetadata(token);\n                return this.serializeTokenData(formatedMetadata, tokenIndex, principal.toText());\n            });\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transferResult = yield this.actor.transfer(to, BigInt(tokenIndex));\n            if ('Err' in transferResult)\n                throw new Error(`${Object.keys(transferResult.Err)[0]}: ${Object.values(transferResult.Err)[0]}`);\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const metadataResult = yield this.actor.tokenMetadata(BigInt(tokenIndex));\n            if ('Err' in metadataResult)\n                throw new Error(`${Object.keys(metadataResult.Err)[0]}: ${Object.values(metadataResult.Err)[0]}`);\n            const metadata = metadataResult.Ok;\n            const formatedMetadata = this.formatMetadata(metadata);\n            const owner = metadata.owner[0] ? metadata.owner[0].toText() : undefined;\n            return this.serializeTokenData(formatedMetadata, tokenIndex, owner);\n        });\n    }\n    serializeTokenData(metadata, tokenIndex, owner) {\n        var _a, _b;\n        return {\n            index: BigInt(tokenIndex),\n            canister: this.canisterId,\n            metadata,\n            owner,\n            url: ((_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.location) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.TextContent) || '',\n            standard: this.standard,\n        };\n    }\n    formatMetadata(metadata) {\n        const metadataResult = { properties: new Array() };\n        metadata.properties.map((prop) => {\n            metadataResult[prop[0]] = { value: prop[1] };\n            metadataResult.properties = [\n                ...metadataResult.properties,\n                { name: prop[0], value: extractMetadataValue(prop[1]) },\n            ];\n        });\n        // Filter out reserved props from the unique traits\n        metadataResult.properties = metadataResult.properties.filter(({ name }) => !['location', 'thumbnail', 'contentHash', 'contentType'].includes(name));\n        return metadataResult;\n    }\n}\nexports[\"default\"] = ERC721;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/dip_721_v2.js?")},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js")["Buffer"];\n\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst ext_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ext.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/ext.did.js"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));\nconst account_1 = __webpack_require__(/*! ../../utils/account */ "../../node_modules/@psychedelic/dab-js/dist/utils/account.js");\nconst number_1 = __webpack_require__(/*! ../../utils/number */ "../../node_modules/@psychedelic/dab-js/dist/utils/number.js");\nconst canisters_1 = __webpack_require__(/*! ../../constants/canisters */ "../../node_modules/@psychedelic/dab-js/dist/constants/canisters.js");\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst getTokenIdentifier = (canister, index) => {\n    const padding = Buffer.from(\'\\x0Atid\');\n    const array = new Uint8Array([\n        ...padding,\n        ...principal_1.Principal.fromText(canister).toUint8Array(),\n        ...(0, number_1.to32bits)(index),\n    ]);\n    return principal_1.Principal.fromUint8Array(array).toText();\n};\nconst extImageUrl = (canisterId, index, tokenIdentifier) => ({\n    [canisters_1.NFT_CANISTERS.WRAPPED_PUNKS]: `https://${canisters_1.NFT_CANISTERS.IC_PUNKS}.raw.ic0.app/Token/${index}`,\n    [canisters_1.NFT_CANISTERS.WRAPPED_DRIP]: `https://${canisters_1.NFT_CANISTERS.IC_DRIP}.raw.ic0.app?tokenId=${index}`,\n}[canisterId] ||\n    `https://${canisterId}.raw.ic0.app/?type=thumbnail&tokenid=${tokenIdentifier}`);\nclass EXT extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.ext;\n        this.actor = agent_1.Actor.createActor(ext_did_1.default, {\n            agent,\n            canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accountId = (0, account_1.getAccountId)(principal);\n            const userTokensResult = yield this.actor.tokens_ext(accountId);\n            if (\'err\' in userTokensResult)\n                throw new Error(`${Object.keys(userTokensResult.err)[0]}: ${Object.values(userTokensResult.err)[0]}`);\n            const tokens = userTokensResult.ok || [];\n            return tokens.map((token) => {\n                const metadata = token[2];\n                const tokenIndex = token[0];\n                return this.serializeTokenData(metadata, getTokenIdentifier(this.canisterId, tokenIndex), tokenIndex);\n            });\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);\n            const from = yield this.agent.getPrincipal();\n            const dummyMemmo = new Array(32).fill(0);\n            const transferResult = yield this.actor.transfer({\n                to: { principal: to },\n                from: { principal: from },\n                token: tokenIdentifier,\n                amount: BigInt(1),\n                memo: dummyMemmo,\n                notify: false,\n                subaccount: [],\n                fee: BigInt(0),\n            });\n            if (\'err\' in transferResult)\n                throw new Error(`${Object.keys(transferResult.err)[0]}: ${Object.values(transferResult.err)[0]}`);\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);\n            const metadataResult = yield this.actor.metadata(tokenIdentifier);\n            if (\'err\' in metadataResult)\n                throw new Error(`${Object.keys(metadataResult.err)[0]}: ${Object.values(metadataResult.err)[0]}`);\n            const { metadata = {} } = \'nonfungible\' in metadataResult.ok ? metadataResult.ok.nonfungible : {};\n            return this.serializeTokenData(metadata, tokenIdentifier, tokenIndex);\n        });\n    }\n    serializeTokenData(metadata, tokenIdentifier, tokenIndex) {\n        return {\n            id: tokenIdentifier,\n            index: BigInt(tokenIndex),\n            canister: this.canisterId,\n            metadata: metadata.length ? metadata[0] : undefined,\n            url: extImageUrl(this.canisterId, tokenIndex, tokenIdentifier),\n            standard: this.standard,\n        };\n    }\n}\nexports["default"] = EXT;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ext.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst icpunks_did_1 = __importDefault(__webpack_require__(/*! ../../idls/icpunks.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/icpunks.did.js"));\nconst default_1 = __importDefault(__webpack_require__(/*! ./default */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/default.js"));\nconst canisters_1 = __webpack_require__(/*! ../../constants/canisters */ "../../node_modules/@psychedelic/dab-js/dist/constants/canisters.js");\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst getICPBunnyCanisterId = (index) => canisters_1.NFT_CANISTERS.ICP_BUNNY_STORAGE[index % 10];\nconst imageUrl = (canisterId, index, tokenDataUrl) => ({\n    [canisters_1.NFT_CANISTERS.ICP_BUNNY_MAIN]: `https://${getICPBunnyCanisterId(index)}.raw.ic0.app/Token/${index}`,\n}[canisterId] || `https://${canisterId}.raw.ic0.app${tokenDataUrl}`);\nclass ICPUNKS extends default_1.default {\n    constructor(canisterId, agent) {\n        super(canisterId, agent);\n        this.standard = standards_1.NFT.icpunks;\n        this.serializeTokenData = (tokenData) => ({\n            index: BigInt(tokenData.id),\n            canister: this.canisterId,\n            url: imageUrl(this.canisterId, Number.parseInt(tokenData.id.toString(), 10), tokenData.url),\n            name: tokenData.name,\n            metadata: tokenData,\n            standard: this.standard,\n        });\n        this.actor = agent_1.Actor.createActor(icpunks_did_1.default, {\n            agent,\n            canisterId,\n        });\n    }\n    getUserTokens(principal) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokensIndexes = yield this.actor.user_tokens(principal);\n            const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => this.actor.data_of(tokenIndex)));\n            return tokensData.map((token) => this.serializeTokenData(token));\n        });\n    }\n    transfer(to, tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const success = yield this.actor.transfer_to(to, BigInt(tokenIndex));\n            if (!success) {\n                throw new Error(\'Error transfering token\');\n            }\n        });\n    }\n    details(tokenIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenData = yield this.actor.data_of(BigInt(tokenIndex));\n            return this.serializeTokenData(tokenData);\n        });\n    }\n}\nexports["default"] = ICPUNKS;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/nft_standards/ic_punks.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/* eslint-disable @typescript-eslint/camelcase */\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst methods_1 = __webpack_require__(/*! ./methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");\nconst getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {\n    const metadataResult = yield actor._getMetadata();\n    return {\n        fungible: {\n            symbol: metadataResult.symbol,\n            decimals: metadataResult.decimals,\n            name: metadataResult.name,\n        },\n    };\n});\nconst send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {\n    const transferResult = yield actor._transfer(principal_1.Principal.fromText(to), amount);\n    if (\'Ok\' in transferResult)\n        return { transactionId: transferResult.Ok.toString() };\n    throw new Error(Object.keys(transferResult.Err)[0]);\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    const decimals = yield getDecimals(actor);\n    const value = (yield actor._balanceOf(user)).toString();\n    return { value, decimals };\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw new Error(\'BURN NOT SUPPORTED\');\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports["default"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ \"../../node_modules/@dfinity/agent/lib/esm/index.js\");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ \"../../node_modules/@dfinity/principal/lib/esm/index.js\");\nconst methods_1 = __webpack_require__(/*! ./methods */ \"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js\");\nconst getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {\n    actor._balance;\n    const token = agent_1.Actor.canisterIdOf(actor).toText();\n    const extensions = yield actor._extensions();\n    if (!extensions.includes('@ext/common'))\n        throw new Error('The provided canister does not implement commont extension');\n    const metadataResult = yield actor._metadata(token);\n    if ('ok' in metadataResult)\n        return metadataResult.ok;\n    throw new Error(Object.keys(metadataResult.err)[0]);\n});\nconst send = (actor, { to, from, amount }) => __awaiter(void 0, void 0, void 0, function* () {\n    const dummyMemmo = new Array(32).fill(0);\n    const token = agent_1.Actor.canisterIdOf(actor).toText();\n    const data = {\n        to: { principal: principal_1.Principal.fromText(to) },\n        from: { principal: principal_1.Principal.from(from) },\n        amount,\n        token,\n        memo: dummyMemmo,\n        notify: false,\n        subaccount: [],\n        fee: BigInt(0),\n    };\n    const transferResult = yield actor._transfer(data);\n    if ('ok' in transferResult)\n        return { amount: transferResult.ok.toString() };\n    throw new Error(Object.keys(transferResult.err)[0]);\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    const token = agent_1.Actor.canisterIdOf(actor).toText();\n    const balanceResult = yield actor._balance({\n        token,\n        user: { principal: user },\n    });\n    const decimals = yield getDecimals(actor);\n    if ('ok' in balanceResult)\n        return { value: balanceResult.ok.toString(), decimals };\n    throw new Error(Object.keys(balanceResult.err)[0]);\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw new Error('BURN NOT SUPPORTED');\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports[\"default\"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js?")},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpMethods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable @typescript-eslint/camelcase */\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ \"../../node_modules/@dfinity/principal/lib/esm/index.js\");\nconst cross_fetch_1 = __importDefault(__webpack_require__(/*! cross-fetch */ \"../../node_modules/cross-fetch/dist/browser-ponyfill.js\"));\nconst methods_1 = __webpack_require__(/*! ./methods */ \"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js\");\nconst account_1 = __webpack_require__(/*! ../../utils/account */ \"../../node_modules/@psychedelic/dab-js/dist/utils/account.js\");\nconst validations_1 = __webpack_require__(/*! ../../utils/validations */ \"../../node_modules/@psychedelic/dab-js/dist/utils/validations.js\");\nconst DECIMALS = 8;\nconst NET_ID = {\n    blockchain: 'Internet Computer',\n    network: '00000000000000020101',\n};\nconst ROSETTA_URL = 'https://rosetta-api.internetcomputer.org';\nconst getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {\n    return {\n        fungible: {\n            symbol: 'ICP',\n            decimals: DECIMALS,\n            name: 'ICP',\n        },\n    };\n});\nconst send = (actor, { to, amount, opts }) => __awaiter(void 0, void 0, void 0, function* () {\n    const defaultArgs = {\n        fee: BigInt(10000),\n        memo: BigInt(0),\n    };\n    const response = yield actor._send_dfx({\n        to: (0, validations_1.validatePrincipalId)(to) ? (0, account_1.getAccountId)(principal_1.Principal.fromText(to)) : to,\n        fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },\n        amount: { e8s: amount },\n        memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,\n        from_subaccount: [],\n        created_at_time: [],\n    });\n    return { height: yield response.toString() };\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    const accountId = (0, account_1.getAccountId)(user);\n    const decimals = yield getDecimals(actor);\n    const response = yield (0, cross_fetch_1.default)(`${ROSETTA_URL}/account/balance`, {\n        method: 'POST',\n        body: JSON.stringify({\n            network_identifier: NET_ID,\n            account_identifier: {\n                address: accountId,\n            },\n        }),\n        headers: {\n            'Content-Type': 'application/json',\n            Accept: '*/*',\n        },\n    });\n    if (!response.ok) {\n        return { value: 'Error', decimals, error: response.statusText };\n    }\n    const { balances } = yield response.json();\n    const [{ value, currency }] = balances;\n    return { value, decimals: currency.decimals };\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw new Error('BURN NOT SUPPORTED');\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports[\"default\"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpMethods.js?")},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/* eslint-disable @typescript-eslint/camelcase */\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst methods_1 = __webpack_require__(/*! ./methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");\nconst account_1 = __webpack_require__(/*! ../../utils/account */ "../../node_modules/@psychedelic/dab-js/dist/utils/account.js");\nconst validations_1 = __webpack_require__(/*! ../../utils/validations */ "../../node_modules/@psychedelic/dab-js/dist/utils/validations.js");\nconst registries_1 = __webpack_require__(/*! ../../registries */ "../../node_modules/@psychedelic/dab-js/dist/registries/index.js");\nconst getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b, _c;\n    const tokenRegistry = new registries_1.TokenRegistry();\n    const token = yield tokenRegistry.get(agent_1.Actor.canisterIdOf(_actor).toString());\n    return {\n        fungible: {\n            symbol: ((_a = token === null || token === void 0 ? void 0 : token.details) === null || _a === void 0 ? void 0 : _a.symbol) || \'ICP\',\n            decimals: ((_b = token === null || token === void 0 ? void 0 : token.details) === null || _b === void 0 ? void 0 : _b.decimals) || 8,\n            name: (token === null || token === void 0 ? void 0 : token.name) || \'ICP\',\n            fee: ((_c = token === null || token === void 0 ? void 0 : token.details) === null || _c === void 0 ? void 0 : _c.fee) || 10000,\n        },\n    };\n});\nconst send = (actor, { to, amount, opts }) => __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield getMetadata(actor);\n    const { fee = 0.002, decimals = BigInt(8) } = (metadata === null || metadata === void 0 ? void 0 : metadata.fungible) || {};\n    const defaultArgs = {\n        fee: BigInt(fee * (Math.pow(10, parseInt(decimals.toString(), 10)))),\n        memo: BigInt(0),\n    };\n    const response = yield actor._send_dfx({\n        to: (0, validations_1.validatePrincipalId)(to) ? (0, account_1.getAccountId)(principal_1.Principal.fromText(to)) : to,\n        fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },\n        amount: { e8s: amount },\n        memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,\n        from_subaccount: [],\n        created_at_time: [],\n    });\n    return { height: yield response.toString() };\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const account = (0, account_1.getAccountId)(user);\n        const balance = yield actor._account_balance_dfx({ account });\n        return { value: balance.e8s.toString(), decimals: 8 };\n    }\n    catch (e) {\n        return { value: \'Error\', decimals: 8, error: \'Error while fetching your balance\' };\n    }\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw new Error(\'BURN NOT SUPPORTED\');\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports["default"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.parseBalance = exports.createTokenActor = void 0;\nconst actorFactory_1 = __webpack_require__(/*! ../../utils/actorFactory */ "../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js");\nconst methods_1 = __importDefault(__webpack_require__(/*! ./methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js"));\nconst xtcMethods_1 = __importDefault(__webpack_require__(/*! ./xtcMethods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js"));\nconst extMethods_1 = __importDefault(__webpack_require__(/*! ./extMethods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/extMethods.js"));\nconst dip20Methods_1 = __importDefault(__webpack_require__(/*! ./dip20Methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/dip20Methods.js"));\nconst ext_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ext.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/ext.did.js"));\nconst xtc_did_1 = __importDefault(__webpack_require__(/*! ../../idls/xtc.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/xtc.did.js"));\nconst dip_20_did_1 = __importDefault(__webpack_require__(/*! ../../idls/dip_20.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/dip_20.did.js"));\nconst ledger_did_1 = __importDefault(__webpack_require__(/*! ../../idls/ledger.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/ledger.did.js"));\nconst standards_1 = __webpack_require__(/*! ../../constants/standards */ "../../node_modules/@psychedelic/dab-js/dist/constants/standards.js");\nconst wicp_did_1 = __importDefault(__webpack_require__(/*! ../../idls/wicp.did */ "../../node_modules/@psychedelic/dab-js/dist/idls/wicp.did.js"));\nconst wicpMethods_1 = __importDefault(__webpack_require__(/*! ./wicpMethods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js"));\nconst icpMethods_1 = __importDefault(__webpack_require__(/*! ./icpMethods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpMethods.js"));\nconst icpStandardMethods_1 = __importDefault(__webpack_require__(/*! ./icpStandardMethods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/icpStandardMethods.js"));\nconst getMethods = (standard) => ({\n    [standards_1.TOKEN.xtc]: xtcMethods_1.default,\n    [standards_1.TOKEN.ext]: extMethods_1.default,\n    [standards_1.TOKEN.dip20]: dip20Methods_1.default,\n    [standards_1.TOKEN.wicp]: wicpMethods_1.default,\n    [standards_1.TOKEN.icp]: icpStandardMethods_1.default,\n}[standard] || methods_1.default);\nconst getIdl = (standard) => {\n    const idl = {\n        [standards_1.TOKEN.xtc]: xtc_did_1.default,\n        [standards_1.TOKEN.ext]: ext_did_1.default,\n        [standards_1.TOKEN.dip20]: dip_20_did_1.default,\n        [standards_1.TOKEN.wicp]: wicp_did_1.default,\n        [standards_1.TOKEN.icp]: ledger_did_1.default\n    }[standard];\n    if (!idl)\n        throw new Error(`Standard ${standard} Not Implemented`);\n    return idl;\n};\nconst createTokenActor = (canisterId, agent, standard) => __awaiter(void 0, void 0, void 0, function* () {\n    const idl = getIdl(standard);\n    const actor = new ((0, actorFactory_1.createExtendedActorClass)(agent, canisterId === \'ryjl3-tyaaa-aaaaa-aaaba-cai\' ? icpMethods_1.default : getMethods(standard), canisterId, idl))();\n    return actor;\n});\nexports.createTokenActor = createTokenActor;\nconst parseBalance = (balance) => {\n    return (parseInt(balance.value, 10) / Math.pow(10, balance.decimals)).toString();\n};\nexports.parseBalance = parseBalance;\nexports["default"] = {};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/index.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js":function(__unused_webpack_module,exports){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAmountToSend = exports.getDecimalsFromMetadata = void 0;\nconst send = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw Error('Standard Not Implemented');\n});\nconst getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {\n    throw Error('Standard Not Implemented');\n});\nconst getBalance = (_actor, _user) => __awaiter(void 0, void 0, void 0, function* () {\n    throw Error('Standard Not Implemented');\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw Error('Standard Not Implemented');\n});\nconst getDecimals = (_actor) => __awaiter(void 0, void 0, void 0, function* () {\n    throw Error('Standard Not Implemented');\n});\nconst getDecimalsFromMetadata = (metadata) => {\n    return 'fungible' in metadata ? metadata.fungible.decimals : 0;\n};\nexports.getDecimalsFromMetadata = getDecimalsFromMetadata;\nconst parseAmountToSend = (amount, decimals) => {\n    return BigInt(parseFloat(amount) * Math.pow(10, decimals));\n};\nexports.parseAmountToSend = parseAmountToSend;\nexports[\"default\"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js?")},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/* eslint-disable @typescript-eslint/camelcase */\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst methods_1 = __webpack_require__(/*! ./methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");\nconst getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {\n    const metadataResult = yield actor._getMetadata();\n    return {\n        fungible: {\n            symbol: metadataResult.symbol,\n            decimals: metadataResult.decimals,\n            name: metadataResult.name,\n        },\n    };\n});\nconst send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {\n    const transferResult = yield actor._transfer(principal_1.Principal.fromText(to), amount);\n    if (\'Ok\' in transferResult)\n        return { transactionId: transferResult.Ok.toString() };\n    throw new Error(Object.keys(transferResult.Err)[0]);\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    const decimals = yield getDecimals(actor);\n    const value = (yield actor._balanceOf(user)).toString();\n    return { value, decimals };\n});\nconst burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {\n    throw new Error(\'BURN NOT SUPPORTED\');\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports["default"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals,\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/wicpMethods.js?')},"../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/* eslint-disable @typescript-eslint/camelcase */\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst methods_1 = __webpack_require__(/*! ./methods */ "../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/methods.js");\nconst getMetadata = (actor) => __awaiter(void 0, void 0, void 0, function* () {\n    const metadataResult = yield actor._getMetadata();\n    return {\n        fungible: {\n            symbol: metadataResult.symbol,\n            decimals: metadataResult.decimals,\n            name: metadataResult.name,\n        },\n    };\n});\nconst send = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {\n    const transferResult = yield actor._transferErc20(principal_1.Principal.fromText(to), amount);\n    if (\'Ok\' in transferResult)\n        return { transactionId: transferResult.Ok.toString() };\n    throw new Error(Object.keys(transferResult.Err)[0]);\n});\nconst getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {\n    const decimals = yield getDecimals(actor);\n    const value = (yield actor._balance([user])).toString();\n    return { value, decimals };\n});\nconst burnXTC = (actor, { to, amount }) => __awaiter(void 0, void 0, void 0, function* () {\n    const decimals = yield getDecimals(actor);\n    const parsedAmount = (0, methods_1.parseAmountToSend)(amount, decimals);\n    return actor._burn({ canister_id: to, amount: parsedAmount });\n});\nconst getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () { return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata(actor)); });\nexports["default"] = {\n    send,\n    getMetadata,\n    getBalance,\n    burnXTC,\n    getDecimals\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/standard_wrappers/token_standards/xtcMethods.js?')},"../../node_modules/@psychedelic/dab-js/dist/utils/account.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../../node_modules/buffer/index.js")["Buffer"];\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getAccountId = void 0;\nconst crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ "../../node_modules/crypto-js/index.js"));\nconst buffer_crc32_1 = __importDefault(__webpack_require__(/*! buffer-crc32 */ "../../node_modules/buffer-crc32/index.js"));\nconst ACCOUNT_DOMAIN_SEPERATOR = \'\\x0Aaccount-id\';\nconst SUB_ACCOUNT_ZERO = Buffer.alloc(32);\nconst byteArrayToWordArray = (byteArray) => {\n    const wordArray = [];\n    let i;\n    for (i = 0; i < byteArray.length; i += 1) {\n        wordArray[(i / 4) | 0] |= byteArray[i] << (24 - 8 * i);\n    }\n    // eslint-disable-next-line\n    const result = crypto_js_1.default.lib.WordArray.create(wordArray, byteArray.length);\n    return result;\n};\nconst wordToByteArray = (word, length) => {\n    const byteArray = [];\n    const xFF = 0xff;\n    if (length > 0)\n        byteArray.push(word >>> 24);\n    if (length > 1)\n        byteArray.push((word >>> 16) & xFF);\n    if (length > 2)\n        byteArray.push((word >>> 8) & xFF);\n    if (length > 3)\n        byteArray.push(word & xFF);\n    return byteArray;\n};\nconst wordArrayToByteArray = (wordArray, length) => {\n    if (wordArray.hasOwnProperty(\'sigBytes\') &&\n        wordArray.hasOwnProperty(\'words\')) {\n        length = wordArray.sigBytes;\n        wordArray = wordArray.words;\n    }\n    let result = [];\n    let bytes;\n    let i = 0;\n    while (length > 0) {\n        bytes = wordToByteArray(wordArray[i], Math.min(4, length));\n        length -= bytes.length;\n        result = [...result, bytes];\n        i++;\n    }\n    return [].concat.apply([], result);\n};\nconst intToHex = (val) => val < 0 ? (Number(val) >>> 0).toString(16) : Number(val).toString(16);\n// We generate a CRC32 checksum, and trnasform it into a hexString\nconst generateChecksum = (hash) => {\n    const crc = buffer_crc32_1.default.unsigned(Buffer.from(hash));\n    const hex = intToHex(crc);\n    return hex.padStart(8, \'0\');\n};\n/*\n    Used dfinity/keysmith/account/account.go as a base for the ID generation\n*/\nconst getAccountId = (principal, subAccount) => {\n    const sha = crypto_js_1.default.algo.SHA224.create();\n    sha.update(ACCOUNT_DOMAIN_SEPERATOR); // Internally parsed with UTF-8, like go does\n    sha.update(byteArrayToWordArray(principal.toUint8Array()));\n    const subBuffer = Buffer.from(SUB_ACCOUNT_ZERO);\n    if (subAccount) {\n        subBuffer.writeUInt32BE(subAccount);\n    }\n    sha.update(byteArrayToWordArray(subBuffer));\n    const hash = sha.finalize();\n    /// While this is backed by an array of length 28, it\'s canonical representation\n    /// is a hex string of length 64. The first 8 characters are the CRC-32 encoded\n    /// hash of the following 56 characters of hex. Both, upper and lower case\n    /// characters are valid in the input string and can even be mixed.\n    /// [ic/rs/rosetta-api/ledger_canister/src/account_identifier.rs]\n    const byteArray = wordArrayToByteArray(hash, 28);\n    const checksum = generateChecksum(byteArray);\n    const val = checksum + hash.toString();\n    return val;\n};\nexports.getAccountId = getAccountId;\nexports["default"] = {};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/utils/account.js?')},"../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.generateActor = exports.createExtendedActorClass = void 0;\nconst agent_1 = __webpack_require__(/*! @dfinity/agent */ "../../node_modules/@dfinity/agent/lib/esm/index.js");\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nconst createExtendedActorClass = (agent, methods, canisterId, IDLFactory) => {\n    class ExtendedActor extends agent_1.Actor.createActorClass(IDLFactory) {\n        constructor() {\n            const principalCanisterId = typeof canisterId === \'string\' ? principal_1.Principal.fromText(canisterId) : canisterId;\n            super({ agent, canisterId: principalCanisterId });\n            Object.keys(this).forEach(methodName => {\n                this[`_${methodName}`] = this[methodName];\n            });\n            Object.keys(methods).forEach(methodName => {\n                this[methodName] = ((...args) => methods[methodName](this, ...args));\n            });\n        }\n    }\n    return ExtendedActor;\n};\nexports.createExtendedActorClass = createExtendedActorClass;\nfunction generateActor({ agent, canisterId, IDL }) {\n    return agent_1.Actor.createActor(IDL, {\n        agent,\n        canisterId: principal_1.Principal.fromText(canisterId),\n    });\n}\nexports.generateActor = generateActor;\nexports["default"] = { createExtendedActorClass: exports.createExtendedActorClass, generateActor };\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/utils/actorFactory.js?')},"../../node_modules/@psychedelic/dab-js/dist/utils/number.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.from32bits = exports.to32bits = void 0;\n/* eslint-disable prefer-template */\n/* eslint-disable no-bitwise */\nconst to32bits = (num) => {\n    const b = new ArrayBuffer(4);\n    new DataView(b).setUint32(0, num);\n    return Array.from(new Uint8Array(b));\n};\nexports.to32bits = to32bits;\nconst from32bits = (ba) => {\n    let value;\n    for (let i = 0; i < 4; i += 1) {\n        value = (value << 8) | ba[i];\n    }\n    return value;\n};\nexports.from32bits = from32bits;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/utils/number.js?')},"../../node_modules/@psychedelic/dab-js/dist/utils/registry.js":function(__unused_webpack_module,exports){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.formatMetadata = exports.formatRegistryDetails = exports.parseDetailValue = void 0;\nconst BOOLEAN_DETAIL_TYPE = ["True", "False"];\nconst parseDetailValue = (detailValue) => {\n    const key = Object.keys(detailValue)[0];\n    const value = BOOLEAN_DETAIL_TYPE.includes(key) ? Boolean(key) : Object.values(detailValue)[0];\n    if (Array.isArray(value)) {\n        return value.map((v) => typeof value === \'number\' ? v : (0, exports.parseDetailValue)(v));\n    }\n    return value;\n};\nexports.parseDetailValue = parseDetailValue;\nconst formatRegistryDetails = (details) => {\n    const formattedDetails = {};\n    for (const [key, detailValue] of details) {\n        formattedDetails[key] = (0, exports.parseDetailValue)(detailValue);\n    }\n    return formattedDetails;\n};\nexports.formatRegistryDetails = formatRegistryDetails;\nconst formatMetadata = (metadata) => (Object.assign(Object.assign({}, metadata), { details: (0, exports.formatRegistryDetails)(metadata.details) }));\nexports.formatMetadata = formatMetadata;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/utils/registry.js?')},"../../node_modules/@psychedelic/dab-js/dist/utils/validations.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateToken = exports.validateCanisterId = exports.validateAccountId = exports.validatePrincipalId = exports.isValidPrincipal = exports.ALPHANUM_REGEX = exports.PRINCIPAL_REGEX = exports.CANISTER_MAX_LENGTH = void 0;\nconst principal_1 = __webpack_require__(/*! @dfinity/principal */ "../../node_modules/@dfinity/principal/lib/esm/index.js");\nexports.CANISTER_MAX_LENGTH = 27;\nexports.PRINCIPAL_REGEX = /(\\w{5}-){10}\\w{3}/;\nexports.ALPHANUM_REGEX = /^[a-zA-Z0-9]+$/;\nconst isValidPrincipal = (text) => principal_1.Principal.fromText(text).toText() === text;\nexports.isValidPrincipal = isValidPrincipal;\nconst validatePrincipalId = (text) => {\n    try {\n        return Boolean(exports.PRINCIPAL_REGEX.test(text) && (0, exports.isValidPrincipal)(text));\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.validatePrincipalId = validatePrincipalId;\nconst validateAccountId = (text) => text.length === 64 && exports.ALPHANUM_REGEX.test(text);\nexports.validateAccountId = validateAccountId;\nconst validateCanisterId = (text) => {\n    try {\n        return Boolean(text.length <= exports.CANISTER_MAX_LENGTH && (0, exports.isValidPrincipal)(text));\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.validateCanisterId = validateCanisterId;\nconst validateToken = (metadata) => Boolean(!!metadata.decimal && !!metadata.name && !!metadata.symbol);\nexports.validateToken = validateToken;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/dist/utils/validations.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/index.js":function(module,__unused_webpack_exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./lib/axios */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/axios.js");\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/index.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/adapters/xhr.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/createError.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/adapters/xhr.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/axios.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./utils */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js");\nvar bind = __webpack_require__(/*! ./helpers/bind */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/bind.js");\nvar Axios = __webpack_require__(/*! ./core/Axios */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/Axios.js");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/mergeConfig.js");\nvar defaults = __webpack_require__(/*! ./defaults */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/CancelToken.js");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/isCancel.js");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/env/data.js").version);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/spread.js");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAxiosError.js");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports["default"] = axios;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/axios.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js":function(module){"use strict";eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/CancelToken.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/CancelToken.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/isCancel.js":function(module){"use strict";eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/isCancel.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/Axios.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/Axios.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/InterceptorManager.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/InterceptorManager.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/buildFullPath.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAbsoluteURL.js");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/combineURLs.js");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/buildFullPath.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/createError.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/createError.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/dispatchRequest.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/dispatchRequest.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/enhanceError.js":function(module){"use strict";eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/enhanceError.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/mergeConfig.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/mergeConfig.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/settle.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/settle.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/transformData.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js");\nvar defaults = __webpack_require__(/*! ./../defaults */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/transformData.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/defaults.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/env/data.js":function(module){eval('module.exports = {\n  "version": "0.24.0"\n};\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/env/data.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/bind.js":function(module){"use strict";eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/bind.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/buildURL.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/buildURL.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/combineURLs.js":function(module){"use strict";eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/combineURLs.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/cookies.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/cookies.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAbsoluteURL.js":function(module){"use strict";eval('\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAbsoluteURL.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAxiosError.js":function(module){"use strict";eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isAxiosError.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isURLSameOrigin.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/isURLSameOrigin.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/normalizeHeaderName.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ../utils */ "../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/normalizeHeaderName.js?')},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/parseHeaders.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/parseHeaders.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/spread.js":function(module){"use strict";eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/spread.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/validator.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/env/data.js\").version);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/validator.js?")},"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/@psychedelic/dab-js/node_modules/axios/lib/utils.js?")},"../../node_modules/ot-json0/lib/bootstrapTransform.js":function(module){eval("// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/ot-json0/lib/bootstrapTransform.js?")},"../../node_modules/ot-json0/lib/index.js":function(module,__unused_webpack_exports,__webpack_require__){eval('// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you\'re welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: __webpack_require__(/*! ./json0 */ "../../node_modules/ot-json0/lib/json0.js")\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/ot-json0/lib/index.js?')},"../../node_modules/ot-json0/lib/json0.js":function(module,__unused_webpack_exports,__webpack_require__){eval("/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        // convert back to old string ops\n        if (c.si != null || c.sd != null) {\n          var p = c.p;\n          for (var i = 0; i < res.length; i++) {\n            c.o = [res[i]];\n            c.p = p.slice();\n            convertToText(c);\n            json.append(dest, c);\n          }\n        } else if (!isArray(res) || res.length > 0) {\n          c.o = res;\n          json.append(dest, c);\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\n__webpack_require__(/*! ./bootstrapTransform */ \"../../node_modules/ot-json0/lib/bootstrapTransform.js\")(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = __webpack_require__(/*! ./text0 */ \"../../node_modules/ot-json0/lib/text0.js\");\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/ot-json0/lib/json0.js?")},"../../node_modules/ot-json0/lib/text0.js":function(module,__unused_webpack_exports,__webpack_require__){eval("// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\n__webpack_require__(/*! ./bootstrapTransform */ \"../../node_modules/ot-json0/lib/bootstrapTransform.js\")(text, transformComponent, checkValidOp, append);\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/ot-json0/lib/text0.js?")},"../../node_modules/performance-now/lib/performance-now.js":function(module){eval('// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/performance-now/lib/performance-now.js?')},"../../node_modules/prefix-style/index.js":function(module){eval("var div = null\nvar prefixes = [ 'Webkit', 'Moz', 'O', 'ms' ]\n\nmodule.exports = function prefixStyle (prop) {\n  // re-use a dummy div\n  if (!div) {\n    div = document.createElement('div')\n  }\n\n  var style = div.style\n\n  // prop exists without prefix\n  if (prop in style) {\n    return prop\n  }\n\n  // borderRadius -> BorderRadius\n  var titleCase = prop.charAt(0).toUpperCase() + prop.slice(1)\n\n  // find the vendor-prefixed prop\n  for (var i = prefixes.length; i >= 0; i--) {\n    var name = prefixes[i] + titleCase\n    // e.g. WebkitBorderRadius or webkitBorderRadius\n    if (name in style) {\n      return name\n    }\n  }\n\n  return false\n}\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prefix-style/index.js?")},"../../node_modules/prop-types/checkPropTypes.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"../../node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"../../node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/checkPropTypes.js?")},"../../node_modules/prop-types/factoryWithTypeCheckers.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"../../node_modules/prop-types/node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"../../node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"../../node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"../../node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"../../node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/factoryWithTypeCheckers.js?")},"../../node_modules/prop-types/index.js":function(module,__unused_webpack_exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/prop-types/node_modules/react-is/index.js");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/index.js?')},"../../node_modules/prop-types/lib/ReactPropTypesSecret.js":function(module){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/lib/ReactPropTypesSecret.js?")},"../../node_modules/prop-types/lib/has.js":function(module){eval("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/lib/has.js?")},"../../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js":function(__unused_webpack_module,exports){"use strict";eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js?")},"../../node_modules/prop-types/node_modules/react-is/index.js":function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval('\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js");\n}\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/prop-types/node_modules/react-is/index.js?')},"../../node_modules/pubsub-js/src/pubsub.js":function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\n * License: MIT - http://mrgnrdrck.mit-license.org\n *\n * https://github.com/mroderick/PubSubJS\n */\n\n(function (root, factory){\n    'use strict';\n\n    var PubSub = {};\n\n    if (root.PubSub) {\n        PubSub = root.PubSub;\n        console.warn(\"PubSub already loaded, using existing version\");\n    } else {\n        root.PubSub = PubSub;\n        factory(PubSub);\n    }\n    // CommonJS and Node.js module support\n    if (true){\n        if (module !== undefined && module.exports) {\n            exports = module.exports = PubSub; // Node.js specific `module.exports`\n        }\n        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\n        module.exports = exports = PubSub; // CommonJS\n    }\n    // AMD support\n    /* eslint-disable no-undef */\n    else {}\n\n}(( typeof window === 'object' && window ) || this, function (PubSub){\n    'use strict';\n\n    var messages = {},\n        lastUid = -1,\n        ALL_SUBSCRIBING_MSG = '*';\n\n    function hasKeys(obj){\n        var key;\n\n        for (key in obj){\n            if ( Object.prototype.hasOwnProperty.call(obj, key) ){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a function that throws the passed exception, for use as argument for setTimeout\n     * @alias throwException\n     * @function\n     * @param { Object } ex An Error object\n     */\n    function throwException( ex ){\n        return function reThrowException(){\n            throw ex;\n        };\n    }\n\n    function callSubscriberWithDelayedExceptions( subscriber, message, data ){\n        try {\n            subscriber( message, data );\n        } catch( ex ){\n            setTimeout( throwException( ex ), 0);\n        }\n    }\n\n    function callSubscriberWithImmediateExceptions( subscriber, message, data ){\n        subscriber( message, data );\n    }\n\n    function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){\n        var subscribers = messages[matchedMessage],\n            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\n            s;\n\n        if ( !Object.prototype.hasOwnProperty.call( messages, matchedMessage ) ) {\n            return;\n        }\n\n        for (s in subscribers){\n            if ( Object.prototype.hasOwnProperty.call(subscribers, s)){\n                callSubscriber( subscribers[s], originalMessage, data );\n            }\n        }\n    }\n\n    function createDeliveryFunction( message, data, immediateExceptions ){\n        return function deliverNamespaced(){\n            var topic = String( message ),\n                position = topic.lastIndexOf( '.' );\n\n            // deliver the message as it is now\n            deliverMessage(message, message, data, immediateExceptions);\n\n            // trim the hierarchy and deliver message to each level\n            while( position !== -1 ){\n                topic = topic.substr( 0, position );\n                position = topic.lastIndexOf('.');\n                deliverMessage( message, topic, data, immediateExceptions );\n            }\n\n            deliverMessage(message, ALL_SUBSCRIBING_MSG, data, immediateExceptions);\n        };\n    }\n\n    function hasDirectSubscribersFor( message ) {\n        var topic = String( message ),\n            found = Boolean(Object.prototype.hasOwnProperty.call( messages, topic ) && hasKeys(messages[topic]));\n\n        return found;\n    }\n\n    function messageHasSubscribers( message ){\n        var topic = String( message ),\n            found = hasDirectSubscribersFor(topic) || hasDirectSubscribersFor(ALL_SUBSCRIBING_MSG),\n            position = topic.lastIndexOf( '.' );\n\n        while ( !found && position !== -1 ){\n            topic = topic.substr( 0, position );\n            position = topic.lastIndexOf( '.' );\n            found = hasDirectSubscribersFor(topic);\n        }\n\n        return found;\n    }\n\n    function publish( message, data, sync, immediateExceptions ){\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        var deliver = createDeliveryFunction( message, data, immediateExceptions ),\n            hasSubscribers = messageHasSubscribers( message );\n\n        if ( !hasSubscribers ){\n            return false;\n        }\n\n        if ( sync === true ){\n            deliver();\n        } else {\n            setTimeout( deliver, 0 );\n        }\n        return true;\n    }\n\n    /**\n     * Publishes the message, passing the data to it's subscribers\n     * @function\n     * @alias publish\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publish = function( message, data ){\n        return publish( message, data, false, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Publishes the message synchronously, passing the data to it's subscribers\n     * @function\n     * @alias publishSync\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publishSync = function( message, data ){\n        return publish( message, data, true, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\n     * @function\n     * @alias subscribe\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { String }\n     */\n    PubSub.subscribe = function( message, func ){\n        if ( typeof func !== 'function'){\n            return false;\n        }\n\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        // message is not registered yet\n        if ( !Object.prototype.hasOwnProperty.call( messages, message ) ){\n            messages[message] = {};\n        }\n\n        // forcing token as String, to allow for future expansions without breaking usage\n        // and allow for easy use as key names for the 'messages' object\n        var token = 'uid_' + String(++lastUid);\n        messages[message][token] = func;\n\n        // return token for unsubscribing\n        return token;\n    };\n\n    PubSub.subscribeAll = function( func ){\n        return PubSub.subscribe(ALL_SUBSCRIBING_MSG, func);\n    };\n\n    /**\n     * Subscribes the passed function to the passed message once\n     * @function\n     * @alias subscribeOnce\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { PubSub }\n     */\n    PubSub.subscribeOnce = function( message, func ){\n        var token = PubSub.subscribe( message, function(){\n            // before func apply, unsubscribe message\n            PubSub.unsubscribe( token );\n            func.apply( this, arguments );\n        });\n        return PubSub;\n    };\n\n    /**\n     * Clears all subscriptions\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearAllSubscriptions = function clearAllSubscriptions(){\n        messages = {};\n    };\n\n    /**\n     * Clear subscriptions by the topic\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     * @return { int }\n     */\n    PubSub.clearSubscriptions = function clearSubscriptions(topic){\n        var m;\n        for (m in messages){\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0){\n                delete messages[m];\n            }\n        }\n    };\n\n    /**\n       Count subscriptions by the topic\n     * @function\n     * @public\n     * @alias countSubscriptions\n     * @return { Array }\n    */\n    PubSub.countSubscriptions = function countSubscriptions(topic){\n        var m;\n        // eslint-disable-next-line no-unused-vars\n        var token;\n        var count = 0;\n        for (m in messages) {\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0) {\n                for (token in messages[m]) {\n                    count++;\n                }\n                break;\n            }\n        }\n        return count;\n    };\n\n\n    /**\n       Gets subscriptions by the topic\n     * @function\n     * @public\n     * @alias getSubscriptions\n    */\n    PubSub.getSubscriptions = function getSubscriptions(topic){\n        var m;\n        var list = [];\n        for (m in messages){\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0){\n                list.push(m);\n            }\n        }\n        return list;\n    };\n\n    /**\n     * Removes subscriptions\n     *\n     * - When passed a token, removes a specific subscription.\n     *\n\t * - When passed a function, removes all subscriptions for that function\n     *\n\t * - When passed a topic, removes all subscriptions for that topic (hierarchy)\n     * @function\n     * @public\n     * @alias subscribeOnce\n     * @param { String | Function } value A token, function or topic to unsubscribe from\n     * @example // Unsubscribing with a token\n     * var token = PubSub.subscribe('mytopic', myFunc);\n     * PubSub.unsubscribe(token);\n     * @example // Unsubscribing with a function\n     * PubSub.unsubscribe(myFunc);\n     * @example // Unsubscribing from a topic\n     * PubSub.unsubscribe('mytopic');\n     */\n    PubSub.unsubscribe = function(value){\n        var descendantTopicExists = function(topic) {\n                var m;\n                for ( m in messages ){\n                    if ( Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0 ){\n                        // a descendant of the topic exists:\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n            isTopic    = typeof value === 'string' && ( Object.prototype.hasOwnProperty.call(messages, value) || descendantTopicExists(value) ),\n            isToken    = !isTopic && typeof value === 'string',\n            isFunction = typeof value === 'function',\n            result = false,\n            m, message, t;\n\n        if (isTopic){\n            PubSub.clearSubscriptions(value);\n            return;\n        }\n\n        for ( m in messages ){\n            if ( Object.prototype.hasOwnProperty.call( messages, m ) ){\n                message = messages[m];\n\n                if ( isToken && message[value] ){\n                    delete message[value];\n                    result = value;\n                    // tokens are unique, so we can just stop here\n                    break;\n                }\n\n                if (isFunction) {\n                    for ( t in message ){\n                        if (Object.prototype.hasOwnProperty.call(message, t) && message[t] === value){\n                            delete message[t];\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n}));\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/pubsub-js/src/pubsub.js?")},"../../node_modules/raf/index.js":function(module,__unused_webpack_exports,__webpack_require__){eval("var now = __webpack_require__(/*! performance-now */ \"../../node_modules/performance-now/lib/performance-now.js\")\n  , root = typeof window === 'undefined' ? __webpack_require__.g : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf\n  object.cancelAnimationFrame = caf\n}\n\n\n//# sourceURL=webpack://@thothai/thoth-client/../../node_modules/raf/index.js?")}}]);